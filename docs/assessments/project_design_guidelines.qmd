---
title: "Golf Modeling App — Mission & Required Features"
subtitle: "A living mission statement and acceptance checklist"
author: "Project Team"
date: "2026-01-08"
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: true
    theme: cosmo
  pdf:
    toc: true
    toc-depth: 3
    number-sections: true
execute:
  echo: true
  warning: false
  message: false
---

## Mission (Non‑Negotiable)

We are building a research‑grade platform to model the golf swing as a constrained, redundant, hybrid multibody system. This is not an animation tool, a curve‑fit engine, or a coaching dashboard. The app must enable physically faithful simulation, cross‑engine verification, and causal interpretation.

**Prime directive:** If a capability does not improve physical fidelity, interpretability, or reproducibility, it does not belong in the product.

## Core Principles

### First principles over convenience

- Equations of motion must be numerically inspectable (and ideally symbolically traceable).
- Jacobians, mass matrices, constraint forces, null spaces, and conditioning are baseline—never “advanced extras.” The goal of this program is to move forward the understanding of golf related physics modelling, to incorporate advanced robotics concepts to the understanding of the golf swing, and to provide the user with the ultimate package of mathematical analysis capabilities in a beautiful user interface where they have clear access to all the information they would ever want. This is the ultimate information product for the advanced biomechanics / robotics student and practitioner. 

### Cross‑engine consistency is a feature

We explicitly support and compare results across:

- Drake
- MuJoCo
- Pinocchio (with Crocoddyl and Pink extensions / packages). The algorithms of Featherstone are a key feature of our advanced modeling system. We want a high performing clean implementation that is ideal for the application of machine learning techniques to nonlinear control problems. 
- Matlab Simscape Multibody Models. These can be called programmatically and will require a local license. This is the only paid product withing the programming suite, and should be considered an optional use case for the user. 
- OpenSim‑class biomechanics features (embedded with full features, advanced analysis capabilities and bringing the best of biomechanics modeling to the ecosystem of this project)
- MyoSuite‑style muscle/neural control experiments. This is designed to augment the capabilities of OpenSim but to do so in a faster to solve package with slightly different capabilities.

Engine disagreements are diagnostics, not something to paper over. Each of these models has different advances features, but we want to make them have as much overlap as we possibly can so that we can generate cross validation opportunities and we can repeat our findings in multiple environments. We want to have easy access for the practitioner to multiple environments that they may use with broadly the same interface. The goal of the program is to do all of the troubleshooting and setup for the practitioner so that they can focus on interpretation of the data. We will deal with the headaches for them and provide the user with a bulletproof and well tested implementation of many different physics and biomechanics modeling engines. We want to bring physical modeling capabilities to the masses in an easy to digest package that computes advanced metrics in as many different ways as possible.

### Closed chains are the norm

Two hands on one club is the default modeling problem. Loop constraints are first‑class and must be interrogated (Jacobian rank, constraint force magnitudes, etc.). The golf swing is a closed chain problem and we need to focus on the advanced techniques that we can use to solve these issues. These are features that are of extreme interest. We want to know and understand the effects of the constraints and how they affect the forces and torques seen throughout the system. We want to explain the null space of the constraint jacobian and we want to understand how we can deal with these loops.

### Drift vs. control must be separable

We require explicit decomposition of motion and acceleration into drift (passive dynamics) and control (actuation), with counterfactual experiments (ZTCF/ZVCF) baked in. The zero torque counterfactual is a term that represents the drift. It is what the forces and torques in the system would be at any given state if the applied torques (control) were suddenly turned off. Similarly the ZVCF represents the forces and torques that would occur if the golfer - club system was in a given state, but the velocities of all components were set to zero (gravity is also set to zero here as it is a separate contributor that is already included in the drift). What we capture in the ZVCF is the control component. The ZTCF captures the drift. 

## System Scope

### Primary workflows

1. **Build or import a model**
   - URDF authoring/generation - we need to have a shared module that allows users to construct and pose urdf models and export states of an urdf model into each of the engines. This module needs to allow for branched chains and closed chain instances with the best practices for parallel mechanisms. The user should be allowed to save and share states, as well as load states. The user should be allowed to change dimensions and inertial properties and should be given good suggestions for typical or appropriate values for different body segments.
   - Engine adapters to adapt the URDF to each engine so that all engines can interact with the same model and perform the same physically (MuJoCo/Pinocchio/Drake/Simscape)
2. **Ingest experimental data**
   - C3D Interpreter Module Functionality (markers + analog + force plates if present)
   - This is critical for the interpretation of biomechanical data00
   - Model fitting / registration
3. **Simulate & optimize**
   - Forward and inverse dynamics
   - Trajectory optimization / planning
   - Advanced non-linear control approaches built in to each model
4. **Interpret**
   - Jacobians, constraints, induced acceleration + indexed acceleration analysis
   - Force/mobility ellipsoids computed at every joint center and the end effector (clubhead).
   - Work and power calculation at every joint. Advanced analysis of energy flow through the system
   - Drift/control decomposition of all forces and torques
   - ZTCF/ZVCF counterfactual computation through advanced simulation strategies
5. **Validate across engines**
   - Comparable outputs, explicit tolerances, documented deviations

### Non‑goals (to stay honest)

- Consumer coaching, “swing tips,” or proprietary scoring.
- Hiding assumptions behind opaque “efficiency metrics.”
- Shipping features that cannot be validated or reproduced.

## Required Feature Set (Acceptance Checklist)

> **Rule:** Every item below must be either (a) implemented, (b) explicitly marked “not supported” with a reason, and (c) tested with an acceptance suite.

### A. Data Ingestion & Experimental Alignment

#### A1. C3D reader (mandatory)

- Read markers, analog channels, events, and metadata.
- Support multiple marker sets and partial/missing markers.
- Unit normalization + sampling‑rate handling.
- Optional force‑plate parsing where present.
- Timebase alignment and resampling utilities.

#### A2. Marker‑to‑model mapping

- Landmark mapping to model frames.
- Segment pose reconstruction (rigid body fit).
- Residuals, outlier detection, and diagnostics plots.
- Logged uncertainty / fit quality metrics.

#### A3. Model fitting & parameter identification

- Fit kinematics (DOFs) to observed trajectories.
- Parameter estimation options (segment lengths, masses/inertias).
- Report sensitivity to parameter changes.

### B. Modeling & Interoperability

#### B1. Kinematic modeling

- Trees and closed loops.
- Revolute, prismatic, and compound joints (universal/spherical via chains).
- Joint limits, damping, compliance options (where supported).

#### B2. Inertial modeling

- Segment mass properties (mass, COM, inertia tensor).
- Consistent conventions across engines.
- Visual vs. collision geometry separation.

#### B3. Interactive URDF generator (mandatory)

- GUI‑driven URDF authoring and editing.
- Parametric joint and link property editing.
- Live URDF validation (schema + physics sanity checks).
- **MuJoCo visualization embedded**:
  - Real‑time render of the generated model
  - Collision display toggles
  - Frame/axis display toggles
  - Joint limit visualization
  - Contact visualization (where possible)

#### B4. Engine adapter layer (mandatory)

- Import/export and runtime adapters for:
  - Drake
  - MuJoCo
  - Pinocchio (+ Crocoddyl + Pink)
  - Simscape Multibody
- Explicit warnings where semantics differ (no silent assumptions).

#### B5. Flexible Beam Shaft Implementation (mandatory)

- Each physics engine must support shaft flexibility modeling options:
  - Rigid shaft (baseline)
  - Finite element beam model (distributed compliance)
  - Modal representation (dominant bending modes)
- Shaft properties:
  - Stiffness distribution (EI profile along shaft)
  - Mass distribution
  - Damping characteristics
- Validation requirements:
  - Static deflection tests (known load → deflection)
  - Dynamic frequency response (compare to modal analysis)
  - Cross-engine comparison of shaft deformation

#### B6. Left-Handed Player Support (mandatory)

- Symmetric model flip functionality:
  - Mirror all kinematic chains about sagittal plane
  - Preserve joint conventions (sign flips for asymmetric joints)
  - Automatic handedness detection from model metadata
- GUI toggle for left/right-handed visualization
- Validation:
  - Mirrored model produces mirrored trajectories
  - Energy/momentum conservation preserved under reflection

### C. Kinematics, Jacobians, and Constraint Geometry

#### C1. Jacobians everywhere (mandatory, exhaustive)

Compute and expose Jacobians for all relevant bodies and task points:

- World‑frame and body‑frame geometric Jacobians (6×N).
- Linear and angular components separated.
- Key task points:
  - Clubhead, multiple points along shaft, grip
  - Left hand, right hand
  - Forearms, upper arms, torso segments
- Closed‑chain, constraint‑consistent Jacobians.

#### C2. Rank/conditioning diagnostics

- Near‑singularity detection (condition number, smallest singular value).
- Constraint Jacobian rank diagnostics.
- Null‑space basis extraction and tracking through time.

#### C3. Screw‑theoretic kinematics (required)

- Instantaneous screw axis (ISA) / twist extraction at key task points.
- Visualization of screw axis and pitch where meaningful.

### D. Dynamics Core (Forward & Inverse)

#### D1. Forward dynamics (mandatory)

- Simulate under applied torques, external wrenches, constraints, gravity.
- Deterministic integration with logged states.
- Toggle contributions:
  - Gravity only
  - Drift only (no applied torques)
  - Control only (no drift terms via counterfactual methods)
  - Constraint force influence isolated (when meaningful)

#### D2. Inverse dynamics (mandatory)

- Constraint‑consistent inverse dynamics.
- Compute:
  - Joint torques for a given motion
  - Constraint reactions (forces/torques)
- Redundant solution options:
  - Minimum‑norm torques
  - Continuity‑regularized torques
  - Null‑space objective costs

#### D3. Mass & inertia matrices (mandatory)

Expose at runtime:

- Joint‑space inertia matrix \(M(q)\)
- Bias terms (Coriolis/centrifugal + gravity effects)
- Operational‑space inertia (task‑space mass matrix) where supported
- Segment inertia tensors and transforms

### E. Forces, Torques, Wrenches, and Power

#### E1. Joint‑level forces/torques (mandatory)

For every joint and timestep, log:

- Applied torque
- Reaction torque (constraint/contacts where relevant)
- Net torque
- Joint power and cumulative work

#### E2. Segment‑level wrenches (mandatory)

- Spatial wrench on each segment.
- Contribution breakdown:
  - parent→child
  - child→parent
  - constraints/contacts
  - external loads

#### E3. Power flow & inter‑segment transfer (required)

- Power transfer between segments (not just system energy).
- Work decomposition aligned with drift/control/constraint components.

#### E4. Reference Frame Representations (mandatory)

**All forces and torques must be available in multiple reference frames:**

- **Global (world) frame**: Fixed inertial reference
- **Local (body) frame**: Attached to each segment
- **Swing plane frame**: Golf-specific task-oriented coordinates

**Swing Plane Reference Frame Requirements:**

- **In-plane component**: Force/torque tangent to instantaneous swing plane
- **Out-of-plane component**: Force/torque perpendicular to swing plane (normal direction)
- **About-grip component**: Moment about the golf grip axis (local coordinate along shaft)
- Real-time plane fitting from:
  - Clubhead velocity vector
  - Grip position trajectory
  - Adjustable time window (user-defined)

**Functional Swing Plane (FSP) — Post-Simulation Analysis:**

- **Definition**: Best-fit plane to clubhead trajectory near impact
- **Fitting window**: User-adjustable time period (e.g., ±50 ms from impact)
- **Outputs**:
  - Plane normal vector and origin
  - RMS deviation of actual trajectory from plane
  - Swing plane angle relative to global frame
- **Integration**: FSP used as reference for final force/torque decomposition
- **Validation**: Compare FSP to instantaneous swing plane evolution

#### E5. Ground Reaction Forces (mandatory)

**All ground reaction forces must be computed and reported:**

- **Reference frame**: GRF calculated in global (world) frame
- **Force plate integration**: Support for C3D analog force plate data
- **Synthetic GRF**: Computed from model contact elements when force plates unavailable
- **Required outputs**:
  - Linear impulse: ∫ F_GRF dt (total and per-foot if bilateral)
  - Angular impulse: ∫ τ_GRF dt about golfer COM
  - Moment of GRF about total golfer center of mass
  - Moment of GRF about golfer-club system COM
  - Center of pressure (COP) trajectory
- **Cross-engine consistency**:
  - GRF magnitude tolerance: ± 5% between engines
  - COP position tolerance: ± 10 mm
  - Angular impulse tolerance: ± 10%

### F. Drift–Control Decomposition (Non‑Negotiable)

We require explicit decomposition of acceleration and power into:

- Drift components:
  - Coriolis/centrifugal coupling
  - gravity effects
  - passive constraint mediation
- Control components:
  - actuation (torques or muscles)
  - control‑dependent constraint interaction

Also required:

- Superposition tests and plots:
  - drift + control = full
- Clear API for “turning off” elements for analysis.

### G. Counterfactuals: ZTCF & ZVCF (Mandatory)

#### G1. ZTCF — Zero‑Torque Counterfactual

- Zero applied torques while preserving state (as defined by the experiment).
- Simulate passive evolution under drift/constraints.
- Compute delta vs. observed motion and infer torque‑attributed effects.

#### G2. ZVCF — Zero‑Velocity Counterfactual

- Zero joint velocities while preserving configuration.
- Isolate acceleration/constraint/gravity‑driven motion from momentum effects.

### H. Induced and Indexed Acceleration Analysis (Mandatory)

#### H1. Induced Acceleration Analysis (IAA)

- Decompose acceleration contributions from:
  - torques (or muscles)
  - gravity
  - Coriolis/centrifugal terms
  - constraints/contacts
- Support both torque‑driven and muscle‑driven models.

#### H2. Indexed acceleration analysis (“IAA++”)

For every timestep, produce labeled acceleration components indexed by cause:

- Applied torque components
- Constraint/loop reaction components
- Gravity components
- Coriolis/centrifugal components
- Muscle components (if present)

Must be available in:

- Joint space (\(\ddot q\))
- Segment COM acceleration
- Clubhead linear + angular acceleration

**Summation requirement:** indexed components must sum to the measured/simulated acceleration within tolerance.

### I. Mobility and Force Ellipsoids (Mandatory)

Compute and visualize for each segment/task point:

- **Mobility (velocity manipulability) ellipsoids**
  - time‑varying through swing phases
  - constraint‑aware where relevant
- **Force transmission ellipsoids**
  - mapping joint torques → task forces
  - constraint‑aware

Ellipsoids must be rendered in 3D with frame context and be exportable.

### J. OpenSim‑Class Biomechanics Features (Embedded)

> We do not merely “export to OpenSim.” We embed comparable analysis capabilities.

Required embedded biomechanics features:

- Hill‑type muscle model support (where used)
- Tendon compliance options
- Muscle routing/wrapping geometry support (baseline)
- Activation → force → joint torque mapping
- Induced acceleration compatible with muscle contributions
- Muscle contribution reports (forces, moments, power)

### K. MyoSuite‑Style Muscle + Neural Control Support

- Ability to run muscle‑driven simulations (as alternatives to torque actuation).
- Support for policy‑driven controllers (RL‑style experiments) as *validation tools*, not hype.
- Hybrid models:
  - muscles for proximal segments
  - torques for distal segments
- Comparative analysis:
  - muscle‑driven vs torque‑driven feasibility
  - energy/effort metrics with transparency


### K2. Contact-Based Grip Model (MuJoCo, mandatory)

**Hand-club interface must be modeled via contact mechanics, not rigid constraints:**

- **Implementation**:
  - MuJoCo contact pairs between hand geometry and grip geometry
  - Friction cone constraints (static/dynamic friction coefficients)
  - Normal force distribution across contact points
- **Required outputs**:
  - Contact forces at each hand-grip interface point
  - Slip detection and magnitude
  - Grip pressure distribution (visualization)
- **Validation tests**:
  - Static equilibrium: club weight supported by contact forces
  - Dynamic swing: contact forces prevent slip within friction limits
  - Comparison to constraint-based grip (residual force analysis)

### K3. Modular Impact Model (MuJoCo, mandatory)

**Ball-clubface impact must be a separate, interfaceable module:**

- **Module architecture**:
  - Standalone impact solver (callable from any engine)
  - Input: Pre-impact state (clubhead velocity, orientation, ball state)
  - Output: Post-impact state (ball velocity, spin, clubhead rebound)
- **Physics models supported**:
  - Rigid body collision (coefficient of restitution)
  - Compliant contact (spring-damper, Kelvin-Voigt)
  - Finite-time contact (impulse-momentum with contact duration)
- **Integration requirements**:
  - MuJoCo native: Use `mj_forward` with contact detection
  - Engine-agnostic: Provide Python API for external impact solvers
- **Validation**:
  - Compare to high-speed video measurements (when available)
  - Energy balance: kinetic energy before/after impact
  - Spin generation models (gear effect, offset impact)
### L. Visualization & Reporting (Not Eye Candy)

Required visual layers:

- Frames, axes, coordinate systems (toggleable)
- Contacts and constraint forces (where supported)
- Jacobian null directions and singularity indicators
- Wrenches and power flow arrows
- Ellipsoids and screw axes
- Swing plane visualization (instantaneous and FSP)

- Ground reaction force vectors and COP trajectory




#### L1. Multi-Perspective Viewpoint Controls (mandatory)



**Easy viewpoint switching for video comparison and machine learning workflows:**



- **Preset camera views**:

  - Face-on (down-the-line, looking at golfer's chest)

  - Down-target-line (DTL, behind golfer looking toward target)

  - Overhead (bird's eye view)

  - Right/left side (90° from target line)

  - Custom angles (user-defined azimuth/elevation)

- **Camera controls**:

  - Smooth transitions between preset views

  - Camera tracking: Follow clubhead, COM, or fixed world position

  - Synchronized multi-view rendering (2×2 or custom grid)

- **Video matching support**:

  - Overlay reference video (semi-transparent)

  - Calibration tools for camera pose matching)

  - Export rendered views with same camera parameters as reference video

- **Use case**: Enable ML-based pose estimation comparison by rendering simulation from same viewpoint as training data



Required exports:

- Standard plots + CSV/NPZ style structured exports
- Engine‑agnostic “analysis bundle” exports for reproducibility

### M. Cross‑Engine Validation & Scientific Hygiene

#### M1. Feature × engine support matrix

For each feature above, we must explicitly state per engine:

- Fully supported / partially supported / unsupported
- Known limitations
- Numerical tolerance targets
- Reference tests that validate the behavior

#### M2. Acceptance test suite (mandatory)

- Deterministic seeds and fixtures.
- “Gold standard” test motions (simple pendulum, double pendulum, closed loop).
- Cross‑engine comparison tests:
  - kinematics
  - dynamics
  - Jacobians/constraints
  - counterfactual deltas
  - indexed acceleration closure

#### M3. Failure reporting is required

The system must detect and report:

- Ill conditioning / near singularities
- Constraint rank loss
- Unrealistic force magnitudes
- Energy drift or integration instability
- Inconsistent conventions across engine adapters

Silence is unacceptable; it must complain loudly and specifically.

## Definition of Done

A release is acceptable only if the platform can answer, for any swing dataset:

1. **What moved?** (kinematics)
2. **What caused it?** (indexed + induced acceleration)
3. **What could have happened instead?** (null space + counterfactuals)
4. **What was controllable?** (mobility/force ellipsoids)
5. **What assumptions mattered?** (constraints + inertias + actuation model)

If any of these cannot be answered with reproducible artifacts, the feature is incomplete.

## Project-Specific Technical Standards

This section defines **mandatory technical requirements** specific to the Golf Modeling Suite that extend the general requirements above.

### N. Code Quality & CI/CD Gates (Non-Negotiable)

All code contributions must pass these automated gates before merge:

#### N1. Formatting & Style

- **Black** (line-length=88, Python 3.11+)
  - Zero tolerance for formatting violations
  - Pre-commit hooks mandatory
- **Ruff** linting with strict rule set:
  - E/W (pycodestyle), F (pyflakes), I (isort), B (bugbear), C4 (comprehensions), UP (pyupgrade), T (print detection)
  - No `print()` statements outside designated paths (tests, scripts, tools, launchers)
  - Import order: Standard → Third-party → Local

#### N2. Type Safety

- **Mypy** strict mode for all production code
  - `disallow_untyped_defs = true`
  - `check_untyped_defs = true`
  - `warn_return_any = true`
- All public functions/methods require type hints (args + return)
- No `Any` without explicit justification comment
- No `# type: ignore` without documented reason

#### N3. Testing Requirements

- **Minimum Coverage**: 25% (Phase 1 target, increasing to 60% by Phase 3)
- **Test Categories** (via pytest markers):
  - `@pytest.mark.unit`: Fast, isolated tests
  - `@pytest.mark.integration`: Cross-component tests
  - `@pytest.mark.slow`: Long-running tests (deselected in CI)
  - `@pytest.mark.mujoco/drake/pinocchio`: Engine-specific tests
- **Deterministic Tests**: All tests must use fixed seeds for RNG
- **No External Dependencies**: Tests must not require network/filesystem access
- **Headless Compatibility**: GUI tests must run in headless environments (Xvfb)

#### N4. Security & Safety

- **No Banned Patterns**:
  - `eval()`, `exec()` (security risk)
  - Mutable default arguments (`def func(items=[])`)
  - Global variables (except constants)
  - Bare `except:` clauses
- **Dependency Scanning**: `pip-audit` must pass (no known vulnerabilities)
- **CSV Injection Prevention**: All user-provided data exported to CSV must be sanitized
- **XML Security**: Use `defusedxml` for all XML parsing

### O. Physics Engine Integration Standards

#### O1. Unified Interface Compliance

All physics engines must implement `PhysicsEngineInterface` from `shared/python/interfaces.py`:

```python
class PhysicsEngineInterface(Protocol):
    def step(self, dt: float) -> None: ...
    def reset(self) -> None: ...
    def get_state(self) -> np.ndarray: ...
    def set_state(self, state: np.ndarray) -> None: ...
    def compute_inverse_dynamics(self, qacc: np.ndarray) -> np.ndarray: ...
    # ... (full interface in shared/python/interfaces.py)
```

#### O2. State Isolation Pattern

- **Thread-Local Data**: Each physics engine instance must use private `MjData`/`MultibodyPlant` contexts
- **No Shared Mutable State**: Engines must not modify global state
- **Context Managers**: Use `with MjDataContext(model):` pattern for temporary state modifications

#### O3. Numerical Stability Requirements

- **Integration Tolerances**:
  - Position drift: < 1e-6 m per second of simulation
  - Energy conservation: < 1% drift for conservative systems
  - Constraint violation: < 1e-8 (normalized)
- **Singularity Detection**:
  - Jacobian condition number warnings at κ > 1e6
  - Automatic fallback to pseudoinverse for κ > 1e10
- **Unit Consistency**:
  - All internal computations in SI units (m, kg, s, rad)
  - Explicit conversion at I/O boundaries

### P. Data Handling & Interoperability Standards

#### P1. C3D Data Requirements

- **Mandatory Metadata**: Frame rate, marker labels, units, analog labels
- **Residual Handling**: NaN for markers with residuals > threshold (default: 10.0 mm)
- **Time Synchronization**: All data aligned to common timebase (frame 0 = t=0)
- **Export Formats**: Must support CSV, JSON (records), NPZ

#### P2. URDF Interchange Format

- **Schema Validation**: All generated URDFs must validate against URDF 1.0 schema
- **Semantic Consistency**:
  - Right-hand coordinate systems (X-forward, Y-left, Z-up for humanoid)
  - Inertia tensors in link-local frames
  - Joint axes normalized to unit vectors
- **Engine-Specific Adaptations**:
  - MuJoCo: Auto-generate `<compiler>` tags for coordinate conventions
  - Drake: Include `<drake:` extensions for contact parameters
  - Pinocchio: Ensure compatibility with `pin.buildModelFromUrdf()`

#### P3. Cross-Engine Validation Protocol

- **Reference Implementation**: Symbolic pendulum models serve as ground truth
- **Tolerance Targets** (to be documented in M1):
  - Kinematics (positions): ± 1e-6 m
  - Kinematics (velocities): ± 1e-5 m/s
  - Dynamics (accelerations): ± 1e-4 m/s²
  - Inverse dynamics (torques): ± 1e-3 N·m
  - Jacobians: ± 1e-8 (element-wise)
- **Deviation Reporting**: Any cross-engine discrepancy > tolerance must log warning with:
  - Engine names
  - Quantity name
  - Measured values
  - Tolerance threshold
  - Possible causes (e.g., integration method, constraint handling)

### Q. GUI & Visualization Standards

#### Q1. PyQt6 Architecture

- **Model-View Separation**: Business logic in separate modules, not in UI classes
- **Signal/Slot Hygiene**:
  - Explicit type annotations for custom signals
  - No lambda slots (use named methods for debuggability)
  - Disconnect signals in cleanup methods
- **Thread Safety**:
  - Long-running computations in `QThread` workers
  - GUI updates only from main thread via signals
  - No blocking operations in event handlers

#### Q2. 3D Visualization Requirements

- **Headless Fallback**: All 3D viewers must detect headless environments and provide:
  - Offscreen rendering (EGL/OSMesa)
  - Screenshot export
  - Graceful degradation message
- **Frame Rate**: Maintain ≥ 30 FPS for real-time visualization
- **Coordinate Frame Indicators**:
  - World frame always visible (toggleable)
  - Body frames color-coded (X=red, Y=green, Z=blue)
  - Scale adaptive to model size

#### Q3. Export & Reproducibility

- **Versioned Exports**: All exported data must include:
  - Schema version
  - Export timestamp (ISO 8601 UTC)
  - Software version (`golf-modeling-suite==X.Y.Z`)
  - Engine name and version
- **Analysis Bundles** (L2 requirement):
  - Single archive (.zip or .tar.gz) containing:
    - Model files (URDF, meshes)
    - Input data (C3D, initial conditions)
    - Simulation parameters (timestep, integrator, tolerances)
    - Output data (states, forces, diagnostics)
    - Metadata (JSON manifest)

### R. Documentation & Knowledge Management

#### R1. Docstring Standards

- **All Public APIs**: NumPy-style docstrings with:
  - One-line summary
  - Extended description (if non-trivial)
  - Args (with types and units where applicable)
  - Returns (with type and shape for arrays)
  - Raises (for expected exceptions)
  - Examples (for complex functions)
- **Physical Units**: Always document units in docstrings:
  ```python
  def compute_torque(force: float, lever_arm: float) -> float:
      """Compute torque from force and lever arm.
      
      Args:
          force: Applied force [N]
          lever_arm: Perpendicular distance [m]
      
      Returns:
          Torque [N·m]
      """
  ```

#### R2. Adversarial Review Cycle

- **Quarterly Assessments**: Run standardized audit prompts (A, B, C) from `docs/assessments/`
- **Prompt A**: Python architecture and software patterns
- **Prompt B**: Scientific rigor and numerical correctness
- **Prompt C**: Physics engine integration and cross-validation
- **Results Storage**: `docs/assessments/Assessment_{A,B,C}_Results.md`
- **Action Items**: All "CRITICAL" findings must be addressed within 2 weeks

#### R3. Changelog & Migration Guides

- **Breaking Changes**: Require migration guide in `docs/development/`
- **Deprecation Policy**: 2-release warning period before removal
- **Version Semantics**: Follow SemVer 2.0.0
  - MAJOR: Breaking API changes
  - MINOR: New features, backward-compatible
  - PATCH: Bug fixes, no API changes

### S. OpenPose Motion Matching Requirements (Ultimate Goal)

These standards apply specifically to the forward dynamics motion matching workflow:

#### S1. Marker-to-Model Registration Pipeline

- **Input**: C3D marker trajectories (≥ 60 Hz recommended)
- **Output**: Joint angle trajectories (q(t)) + residuals
- **IK Solver Requirements**:
  - Constraint-consistent (respect closed loops)
  - Regularization for redundant DOFs (damped least squares, λ = 0.01)
  - Per-frame residual reporting (RMS marker error)
  - Outlier detection (residual > 3σ flagged)
- **Parameter Estimation**:
  - Segment lengths from marker geometry
  - Mass/inertia from anthropometric tables (with uncertainty bounds)
  - Sensitivity analysis (∂q/∂p for key parameters p)

#### S2. Trajectory Optimization Standards

- **Objective Function**:
  - Primary: Minimize marker residuals (weighted least squares)
  - Secondary: Minimize control effort (∫ τ² dt)
  - Tertiary: Smoothness penalty (∫ q̈² dt)
- **Constraints**:
  - Dynamics feasibility (M(q)q̈ + C(q,q̇) + G(q) = τ)
  - Joint limits (q_min ≤ q ≤ q_max)
  - Torque limits (|τ| ≤ τ_max, from biomechanical data)
  - Contact constraints (if ground interaction modeled)
- **Solver Requirements**:
  - Support for direct collocation or shooting methods
  - Warm-start from IK solution
  - Convergence tolerance: cost reduction < 1e-6 or max 500 iterations

#### S3. Validation Metrics

- **Kinematic Fidelity**:
  - Marker RMS error < 10 mm (excellent), < 20 mm (acceptable)
  - Joint angle correlation with IK solution: R² > 0.95
- **Dynamic Consistency**:
  - Indexed acceleration closure: |q̈_total - Σ q̈_components| < 1e-3 rad/s²
  - Energy balance: |ΔE - W_external| < 5% (for conservative phases)
- **Cross-Engine Agreement**:
  - Torque profiles: RMS difference < 10% between engines
  - Clubhead trajectory: position error < 5 mm, velocity error < 0.5 m/s

---

### T. AI Assistant Integration & Accessibility (Non-Negotiable)

This section defines **mandatory requirements** for the AI-first transformation of the Golf Modeling Suite. The goal is to maintain scientific rigor (9.4/10 quality baseline) while democratizing access for non-expert users through AI-guided workflows.

**Prime Directive:** The AI assistant educates and guides; it never bypasses scientific validation.

#### T1. Agent-Agnostic Architecture (mandatory)

The AI integration must support multiple LLM providers without vendor lock-in:

- **Provider Support**:
  - OpenAI (GPT-4, GPT-4 Turbo)
  - Anthropic (Claude 3.x)
  - Google (Gemini)
  - Ollama (Local, FREE) — must be fully functional
  - Custom endpoints via adapter interface
- **Cost Model**:
  - Zero developer infrastructure cost
  - Users provide their own API keys
  - Fully functional without AI (graceful degradation)
- **Implementation**:
  - Agent Interface Protocol (AIP) server using JSON-RPC 2.0
  - Provider adapters translate between AIP and provider APIs
  - Capability negotiation for provider-specific features

#### T2. Workflow Engine & Guided Execution (mandatory)

Step-by-step workflows for common analyses:

- **Built-in Workflows** (minimum):
  - `first_analysis`: Complete beginner walkthrough
  - `c3d_import`: Load and validate motion capture data
  - `inverse_dynamics`: Compute joint torques
  - `cross_engine_validation`: Multi-engine comparison
  - `drift_control_decomposition`: Causal analysis
- **Workflow Features**:
  - Validation at each step with clear pass/fail feedback
  - Error recovery strategies (retry, skip, fallback, ask user)
  - Progress tracking visualization
  - Educational content interwoven with execution
- **Quality Checks**:
  - Energy conservation verification
  - Cross-engine consistency checks
  - Physical plausibility validation (torque limits, etc.)

#### T3. Educational Content System (mandatory)

Progressive disclosure with 4 expertise levels:

- **Expertise Levels**:
  - **Beginner**: No prior knowledge assumed
  - **Intermediate**: Basic physics/biomechanics understanding
  - **Advanced**: Graduate-level comprehension
  - **Expert**: Research-publication ready
- **Content Requirements**:
  - 500+ term glossary with multi-level explanations
  - Just-in-time concept explanations during workflows
  - Visual guides and diagrams for complex concepts
  - Code examples with interpretation
- **User Progression**:
  - Track user expertise level
  - Suggest topics for advancement
  - Unlock advanced features as proficiency grows

#### T4. Quality Assurance & Result Interpretation (mandatory)

Automated assessment of analysis quality:

- **Validation Checks**:
  - Energy conservation: |ΔE| < 1% for conservative phases
  - Torque plausibility: Within biomechanical limits (~500 N·m max)
  - Cross-engine agreement: Per Section P3 tolerances
  - Numerical stability: Jacobian condition number warnings
- **Result Interpretation**:
  - "Is this good?" assessment for all outputs
  - Suggested next steps based on results
  - Confidence indicators and uncertainty visualization
  - Comparison to expected ranges (where available)

#### T5. User Interface Integration (mandatory)

AI Assistant Panel in the Golf Suite Launcher:

- **Components**:
  - Conversation interface with history
  - Workflow progress tracker
  - Tool execution visualization
  - Provider configuration dialog
  - Quick action shortcuts
- **Accessibility**:
  - Beginner/Expert mode toggle
  - Keyboard navigation support
  - Clear visual hierarchy
  - Status indicators for AI connection

#### T6. Security, Privacy & Auditability (mandatory)

Strict data handling requirements:

- **API Key Security**:
  - Store in OS keyring (Windows Credential Manager / macOS Keychain / Linux Secret Service)
  - Never log API keys
  - Never transmit to developers
  - Secure deletion on removal
- **Data Privacy**:
  - Conversation history stored locally only
  - Model files never sent to AI providers (only metadata)
  - User controls all data transmission
  - Optional (user-consent) error reporting
- **Audit Trail**:
  - Log all AI tool executions
  - Reproducibility metadata for all analyses
  - Timestamp and session tracking

#### T7. Implementation Requirements (mandatory)

Technical standards for AI code:

- **Code Quality**:
  - Black/Ruff/Mypy strict compliance (same as Section N)
  - Minimum 50% test coverage for AI modules
  - No banned patterns (`eval`, mutable defaults)
  - Type hints on all public APIs
- **Architecture**:
  - Separation of UI and business logic
  - Async processing for long operations
  - Graceful timeout handling
  - Error messages with educational context
- **Dependencies**:
  - Optional AI dependencies (user installs if using AI)
  - No core functionality degradation without AI
  - Pinned versions for provider SDKs

#### T8. Success Metrics (mandatory)

Measurable outcomes for AI integration:

- **Accessibility Metrics**:
  - Time to first successful analysis: <30 minutes for beginners
  - Beginner success rate: >80% completion
  - Error recovery rate: >90% with AI guidance
  - User progression: Beginner → Intermediate in 5 sessions
- **Technical Metrics**:
  - AI response latency: <3 seconds (P95)
  - Workflow completion rate: >95%
  - Scientific validation pass rate: 100%
- **Quality Metrics**:
  - CI/CD pass rate: 100%
  - Test coverage: >50% for AI modules
  - Security vulnerabilities: 0

#### T9. Rollout Strategy (recommended)

Phased implementation approach:

- **Phase 1: Core Infrastructure (3 weeks)**:
  - AIP Server and provider adapters
  - Tool Registry and Workflow Engine
  - Basic educational content
- **Phase 2: GUI Integration (2 weeks)**:
  - AI Assistant Panel
  - Configuration dialogs
  - Workflow visualization
- **Phase 3: Content Creation (3 weeks)**:
  - Multi-level explanations
  - Glossary expansion
  - Demo workflows
- **Phase 4: Testing & Refinement (2 weeks)**:
  - User acceptance testing
  - Performance optimization
  - Security audit

#### T10. Non-Negotiable Quality Standards

These standards are absolute and cannot be waived:

1. **Scientific Integrity**: AI suggestions never bypass scientific validation
2. **Reproducibility**: All AI-assisted analyses must be reproducible
3. **Transparency**: Users always understand what the AI did
4. **Educational Accuracy**: Content is scientifically correct and citable
5. **Privacy Protection**: API keys and user data are never exposed
6. **Graceful Degradation**: System fully functional without AI features

---

## Appendix: Suggested "Causality Demo" Test Case

A standard benchmark swing (or simplified analog) used to validate every engine:

- Closed‑chain two‑hand club constraint enabled
- Prescribed kinematics segment (for inverse dynamics)
- Free swing segment (for drift/counterfactual)
- Perturbation tests:
  - torque perturbations
  - parameter perturbations (mass/inertia/length)
  - constraint stiffness (if applicable)
- Required outputs:
  - ZTCF/ZVCF deltas
  - induced + indexed acceleration closure
  - ellipsoid evolution
  - cross‑engine comparison report
