---
title: "Golf Modeling App — Mission & Required Features"
subtitle: "A living mission statement and acceptance checklist"
author: "Project Team"
date: "2026-01-05"
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: true
    theme: cosmo
  pdf:
    toc: true
    toc-depth: 3
    number-sections: true
execute:
  echo: true
  warning: false
  message: false
---

## Mission (Non‑Negotiable)

We are building a research‑grade platform to model the golf swing as a constrained, redundant, hybrid multibody system. This is not an animation tool, a curve‑fit engine, or a coaching dashboard. The app must enable physically faithful simulation, cross‑engine verification, and causal interpretation.

**Prime directive:** If a capability does not improve physical fidelity, interpretability, or reproducibility, it does not belong in the product.

## Core Principles

### First principles over convenience

- Equations of motion must be numerically inspectable (and ideally symbolically traceable).
- Jacobians, mass matrices, constraint forces, null spaces, and conditioning are baseline—never “advanced extras.” The goal of this program is to move forward the understanding of golf related physics modelling, to incorporate advanced robotics concepts to the understanding of the golf swing, and to provide the user with the ultimate package of mathematical analysis capabilities in a beautiful user interface where they have clear access to all the information they would ever want. This is the ultimate information product for the advanced biomechanics / robotics student and practitioner. 

### Cross‑engine consistency is a feature

We explicitly support and compare results across:

- Drake
- MuJoCo
- Pinocchio (with Crocoddyl and Pink extensions / packages). The algorithms of Featherstone are a key feature of our advanced modeling system. We want a high performing clean implementation that is ideal for the application of machine learning techniques to nonlinear control problems. 
- Matlab Simscape Multibody Models. These can be called programmatically and will require a local license. This is the only paid product withing the programming suite, and should be considered an optional use case for the user. 
- OpenSim‑class biomechanics features (embedded with full features, advanced analysis capabilities and bringing the best of biomechanics modeling to the ecosystem of this project)
- MyoSuite‑style muscle/neural control experiments. This is designed to augment the capabilities of OpenSim but to do so in a faster to solve package with slightly different capabilities.

Engine disagreements are diagnostics, not something to paper over. Each of these models has different advances features, but we want to make them have as much overlap as we possibly can so that we can generate cross validation opportunities and we can repeat our findings in multiple environments. We want to have easy access for the practitioner to multiple environments that they may use with broadly the same interface. The goal of the program is to do all of the troubleshooting and setup for the practitioner so that they can focus on interpretation of the data. We will deal with the headaches for them and provide the user with a bulletproof and well tested implementation of many different physics and biomechanics modeling engines. We want to bring physical modeling capabilities to the masses in an easy to digest package that computes advanced metrics in as many different ways as possible.

### Closed chains are the norm

Two hands on one club is the default modeling problem. Loop constraints are first‑class and must be interrogated (Jacobian rank, constraint force magnitudes, etc.). The golf swing is a closed chain problem and we need to focus on the advanced techniques that we can use to solve these issues. These are features that are of extreme interest. We want to know and understand the effects of the constraints and how they affect the forces and torques seen throughout the system. We want to explain the null space of the constraint jacobian and we want to understand how we can deal with these loops.

### Drift vs. control must be separable

We require explicit decomposition of motion and acceleration into drift (passive dynamics) and control (actuation), with counterfactual experiments (ZTCF/ZVCF) baked in. The zero torque counterfactual is a term that represents the drift. It is what the forces and torques in the system would be at any given state if the applied torques (control) were suddenly turned off. Similarly the ZVCF represents the forces and torques that would occur if the golfer - club system was in a given state, but the velocities of all components were set to zero (gravity is also set to zero here as it is a separate contributor that is already included in the drift). What we capture in the ZVCF is the control component. The ZTCF captures the drift. 

## System Scope

### Primary workflows

1. **Build or import a model**
   - URDF authoring/generation - we need to have a shared module that allows users to construct and pose urdf models and export states of an urdf model into each of the engines. This module needs to allow for branched chains and closed chain instances with the best practices for parallel mechanisms. The user should be allowed to save and share states, as well as load states. The user should be allowed to change dimensions and inertial properties and should be given good suggestions for typical or appropriate values for different body segments.
   - Engine adapters to adapt the URDF to each engine so that all engines can interact with the same model and perform the same physically (MuJoCo/Pinocchio/Drake/Simscape)
2. **Ingest experimental data**
   - C3D Interpreter Module Functionality (markers + analog + force plates if present)
   - This is critical for the interpretation of biomechanical data00
   - Model fitting / registration
3. **Simulate & optimize**
   - Forward and inverse dynamics
   - Trajectory optimization / planning
   - Advanced non-linear control approaches built in to each model
4. **Interpret**
   - Jacobians, constraints, induced acceleration + indexed acceleration analysis
   - Force/mobility ellipsoids computed at every joint center and the end effector (clubhead).
   - Work and power calculation at every joint. Advanced analysis of energy flow through the system
   - Drift/control decomposition of all forces and torques
   - ZTCF/ZVCF counterfactual computation through advanced simulation strategies
5. **Validate across engines**
   - Comparable outputs, explicit tolerances, documented deviations

### Non‑goals (to stay honest)

- Consumer coaching, “swing tips,” or proprietary scoring.
- Hiding assumptions behind opaque “efficiency metrics.”
- Shipping features that cannot be validated or reproduced.

## Required Feature Set (Acceptance Checklist)

> **Rule:** Every item below must be either (a) implemented, (b) explicitly marked “not supported” with a reason, and (c) tested with an acceptance suite.

### A. Data Ingestion & Experimental Alignment

#### A1. C3D reader (mandatory)

- Read markers, analog channels, events, and metadata.
- Support multiple marker sets and partial/missing markers.
- Unit normalization + sampling‑rate handling.
- Optional force‑plate parsing where present.
- Timebase alignment and resampling utilities.

#### A2. Marker‑to‑model mapping

- Landmark mapping to model frames.
- Segment pose reconstruction (rigid body fit).
- Residuals, outlier detection, and diagnostics plots.
- Logged uncertainty / fit quality metrics.

#### A3. Model fitting & parameter identification

- Fit kinematics (DOFs) to observed trajectories.
- Parameter estimation options (segment lengths, masses/inertias).
- Report sensitivity to parameter changes.

### B. Modeling & Interoperability

#### B1. Kinematic modeling

- Trees and closed loops.
- Revolute, prismatic, and compound joints (universal/spherical via chains).
- Joint limits, damping, compliance options (where supported).

#### B2. Inertial modeling

- Segment mass properties (mass, COM, inertia tensor).
- Consistent conventions across engines.
- Visual vs. collision geometry separation.

#### B3. Interactive URDF generator (mandatory)

- GUI‑driven URDF authoring and editing.
- Parametric joint and link property editing.
- Live URDF validation (schema + physics sanity checks).
- **MuJoCo visualization embedded**:
  - Real‑time render of the generated model
  - Collision display toggles
  - Frame/axis display toggles
  - Joint limit visualization
  - Contact visualization (where possible)

#### B4. Engine adapter layer (mandatory)

- Import/export and runtime adapters for:
  - Drake
  - MuJoCo
  - Pinocchio (+ Crocoddyl + Pink)
  - Simscape Multibody
- Explicit warnings where semantics differ (no silent assumptions).

### C. Kinematics, Jacobians, and Constraint Geometry

#### C1. Jacobians everywhere (mandatory, exhaustive)

Compute and expose Jacobians for all relevant bodies and task points:

- World‑frame and body‑frame geometric Jacobians (6×N).
- Linear and angular components separated.
- Key task points:
  - Clubhead, multiple points along shaft, grip
  - Left hand, right hand
  - Forearms, upper arms, torso segments
- Closed‑chain, constraint‑consistent Jacobians.

#### C2. Rank/conditioning diagnostics

- Near‑singularity detection (condition number, smallest singular value).
- Constraint Jacobian rank diagnostics.
- Null‑space basis extraction and tracking through time.

#### C3. Screw‑theoretic kinematics (required)

- Instantaneous screw axis (ISA) / twist extraction at key task points.
- Visualization of screw axis and pitch where meaningful.

### D. Dynamics Core (Forward & Inverse)

#### D1. Forward dynamics (mandatory)

- Simulate under applied torques, external wrenches, constraints, gravity.
- Deterministic integration with logged states.
- Toggle contributions:
  - Gravity only
  - Drift only (no applied torques)
  - Control only (no drift terms via counterfactual methods)
  - Constraint force influence isolated (when meaningful)

#### D2. Inverse dynamics (mandatory)

- Constraint‑consistent inverse dynamics.
- Compute:
  - Joint torques for a given motion
  - Constraint reactions (forces/torques)
- Redundant solution options:
  - Minimum‑norm torques
  - Continuity‑regularized torques
  - Null‑space objective costs

#### D3. Mass & inertia matrices (mandatory)

Expose at runtime:

- Joint‑space inertia matrix \(M(q)\)
- Bias terms (Coriolis/centrifugal + gravity effects)
- Operational‑space inertia (task‑space mass matrix) where supported
- Segment inertia tensors and transforms

### E. Forces, Torques, Wrenches, and Power

#### E1. Joint‑level forces/torques (mandatory)

For every joint and timestep, log:

- Applied torque
- Reaction torque (constraint/contacts where relevant)
- Net torque
- Joint power and cumulative work

#### E2. Segment‑level wrenches (mandatory)

- Spatial wrench on each segment.
- Contribution breakdown:
  - parent→child
  - child→parent
  - constraints/contacts
  - external loads

#### E3. Power flow & inter‑segment transfer (required)

- Power transfer between segments (not just system energy).
- Work decomposition aligned with drift/control/constraint components.

### F. Drift–Control Decomposition (Non‑Negotiable)

We require explicit decomposition of acceleration and power into:

- Drift components:
  - Coriolis/centrifugal coupling
  - gravity effects
  - passive constraint mediation
- Control components:
  - actuation (torques or muscles)
  - control‑dependent constraint interaction

Also required:

- Superposition tests and plots:
  - drift + control = full
- Clear API for “turning off” elements for analysis.

### G. Counterfactuals: ZTCF & ZVCF (Mandatory)

#### G1. ZTCF — Zero‑Torque Counterfactual

- Zero applied torques while preserving state (as defined by the experiment).
- Simulate passive evolution under drift/constraints.
- Compute delta vs. observed motion and infer torque‑attributed effects.

#### G2. ZVCF — Zero‑Velocity Counterfactual

- Zero joint velocities while preserving configuration.
- Isolate acceleration/constraint/gravity‑driven motion from momentum effects.

### H. Induced and Indexed Acceleration Analysis (Mandatory)

#### H1. Induced Acceleration Analysis (IAA)

- Decompose acceleration contributions from:
  - torques (or muscles)
  - gravity
  - Coriolis/centrifugal terms
  - constraints/contacts
- Support both torque‑driven and muscle‑driven models.

#### H2. Indexed acceleration analysis (“IAA++”)

For every timestep, produce labeled acceleration components indexed by cause:

- Applied torque components
- Constraint/loop reaction components
- Gravity components
- Coriolis/centrifugal components
- Muscle components (if present)

Must be available in:

- Joint space (\(\ddot q\))
- Segment COM acceleration
- Clubhead linear + angular acceleration

**Summation requirement:** indexed components must sum to the measured/simulated acceleration within tolerance.

### I. Mobility and Force Ellipsoids (Mandatory)

Compute and visualize for each segment/task point:

- **Mobility (velocity manipulability) ellipsoids**
  - time‑varying through swing phases
  - constraint‑aware where relevant
- **Force transmission ellipsoids**
  - mapping joint torques → task forces
  - constraint‑aware

Ellipsoids must be rendered in 3D with frame context and be exportable.

### J. OpenSim‑Class Biomechanics Features (Embedded)

> We do not merely “export to OpenSim.” We embed comparable analysis capabilities.

Required embedded biomechanics features:

- Hill‑type muscle model support (where used)
- Tendon compliance options
- Muscle routing/wrapping geometry support (baseline)
- Activation → force → joint torque mapping
- Induced acceleration compatible with muscle contributions
- Muscle contribution reports (forces, moments, power)

### K. MyoSuite‑Style Muscle + Neural Control Support

- Ability to run muscle‑driven simulations (as alternatives to torque actuation).
- Support for policy‑driven controllers (RL‑style experiments) as *validation tools*, not hype.
- Hybrid models:
  - muscles for proximal segments
  - torques for distal segments
- Comparative analysis:
  - muscle‑driven vs torque‑driven feasibility
  - energy/effort metrics with transparency

### L. Visualization & Reporting (Not Eye Candy)

Required visual layers:

- Frames, axes, coordinate systems (toggleable)
- Contacts and constraint forces (where supported)
- Jacobian null directions and singularity indicators
- Wrenches and power flow arrows
- Ellipsoids and screw axes

Required exports:

- Standard plots + CSV/NPZ style structured exports
- Engine‑agnostic “analysis bundle” exports for reproducibility

### M. Cross‑Engine Validation & Scientific Hygiene

#### M1. Feature × engine support matrix

For each feature above, we must explicitly state per engine:

- Fully supported / partially supported / unsupported
- Known limitations
- Numerical tolerance targets
- Reference tests that validate the behavior

#### M2. Acceptance test suite (mandatory)

- Deterministic seeds and fixtures.
- “Gold standard” test motions (simple pendulum, double pendulum, closed loop).
- Cross‑engine comparison tests:
  - kinematics
  - dynamics
  - Jacobians/constraints
  - counterfactual deltas
  - indexed acceleration closure

#### M3. Failure reporting is required

The system must detect and report:

- Ill conditioning / near singularities
- Constraint rank loss
- Unrealistic force magnitudes
- Energy drift or integration instability
- Inconsistent conventions across engine adapters

Silence is unacceptable; it must complain loudly and specifically.

## Definition of Done

A release is acceptable only if the platform can answer, for any swing dataset:

1. **What moved?** (kinematics)
2. **What caused it?** (indexed + induced acceleration)
3. **What could have happened instead?** (null space + counterfactuals)
4. **What was controllable?** (mobility/force ellipsoids)
5. **What assumptions mattered?** (constraints + inertias + actuation model)

If any of these cannot be answered with reproducible artifacts, the feature is incomplete.

## Project-Specific Technical Standards

This section defines **mandatory technical requirements** specific to the Golf Modeling Suite that extend the general requirements above.

### N. Code Quality & CI/CD Gates (Non-Negotiable)

All code contributions must pass these automated gates before merge:

#### N1. Formatting & Style

- **Black** (line-length=88, Python 3.11+)
  - Zero tolerance for formatting violations
  - Pre-commit hooks mandatory
- **Ruff** linting with strict rule set:
  - E/W (pycodestyle), F (pyflakes), I (isort), B (bugbear), C4 (comprehensions), UP (pyupgrade), T (print detection)
  - No `print()` statements outside designated paths (tests, scripts, tools, launchers)
  - Import order: Standard → Third-party → Local

#### N2. Type Safety

- **Mypy** strict mode for all production code
  - `disallow_untyped_defs = true`
  - `check_untyped_defs = true`
  - `warn_return_any = true`
- All public functions/methods require type hints (args + return)
- No `Any` without explicit justification comment
- No `# type: ignore` without documented reason

#### N3. Testing Requirements

- **Minimum Coverage**: 25% (Phase 1 target, increasing to 60% by Phase 3)
- **Test Categories** (via pytest markers):
  - `@pytest.mark.unit`: Fast, isolated tests
  - `@pytest.mark.integration`: Cross-component tests
  - `@pytest.mark.slow`: Long-running tests (deselected in CI)
  - `@pytest.mark.mujoco/drake/pinocchio`: Engine-specific tests
- **Deterministic Tests**: All tests must use fixed seeds for RNG
- **No External Dependencies**: Tests must not require network/filesystem access
- **Headless Compatibility**: GUI tests must run in headless environments (Xvfb)

#### N4. Security & Safety

- **No Banned Patterns**:
  - `eval()`, `exec()` (security risk)
  - Mutable default arguments (`def func(items=[])`)
  - Global variables (except constants)
  - Bare `except:` clauses
- **Dependency Scanning**: `pip-audit` must pass (no known vulnerabilities)
- **CSV Injection Prevention**: All user-provided data exported to CSV must be sanitized
- **XML Security**: Use `defusedxml` for all XML parsing

### O. Physics Engine Integration Standards

#### O1. Unified Interface Compliance

All physics engines must implement `PhysicsEngineInterface` from `shared/python/interfaces.py`:

```python
class PhysicsEngineInterface(Protocol):
    def step(self, dt: float) -> None: ...
    def reset(self) -> None: ...
    def get_state(self) -> np.ndarray: ...
    def set_state(self, state: np.ndarray) -> None: ...
    def compute_inverse_dynamics(self, qacc: np.ndarray) -> np.ndarray: ...
    # ... (full interface in shared/python/interfaces.py)
```

#### O2. State Isolation Pattern

- **Thread-Local Data**: Each physics engine instance must use private `MjData`/`MultibodyPlant` contexts
- **No Shared Mutable State**: Engines must not modify global state
- **Context Managers**: Use `with MjDataContext(model):` pattern for temporary state modifications

#### O3. Numerical Stability Requirements

- **Integration Tolerances**:
  - Position drift: < 1e-6 m per second of simulation
  - Energy conservation: < 1% drift for conservative systems
  - Constraint violation: < 1e-8 (normalized)
- **Singularity Detection**:
  - Jacobian condition number warnings at κ > 1e6
  - Automatic fallback to pseudoinverse for κ > 1e10
- **Unit Consistency**:
  - All internal computations in SI units (m, kg, s, rad)
  - Explicit conversion at I/O boundaries

### P. Data Handling & Interoperability Standards

#### P1. C3D Data Requirements

- **Mandatory Metadata**: Frame rate, marker labels, units, analog labels
- **Residual Handling**: NaN for markers with residuals > threshold (default: 10.0 mm)
- **Time Synchronization**: All data aligned to common timebase (frame 0 = t=0)
- **Export Formats**: Must support CSV, JSON (records), NPZ

#### P2. URDF Interchange Format

- **Schema Validation**: All generated URDFs must validate against URDF 1.0 schema
- **Semantic Consistency**:
  - Right-hand coordinate systems (X-forward, Y-left, Z-up for humanoid)
  - Inertia tensors in link-local frames
  - Joint axes normalized to unit vectors
- **Engine-Specific Adaptations**:
  - MuJoCo: Auto-generate `<compiler>` tags for coordinate conventions
  - Drake: Include `<drake:` extensions for contact parameters
  - Pinocchio: Ensure compatibility with `pin.buildModelFromUrdf()`

#### P3. Cross-Engine Validation Protocol

- **Reference Implementation**: Symbolic pendulum models serve as ground truth
- **Tolerance Targets** (to be documented in M1):
  - Kinematics (positions): ± 1e-6 m
  - Kinematics (velocities): ± 1e-5 m/s
  - Dynamics (accelerations): ± 1e-4 m/s²
  - Inverse dynamics (torques): ± 1e-3 N·m
  - Jacobians: ± 1e-8 (element-wise)
- **Deviation Reporting**: Any cross-engine discrepancy > tolerance must log warning with:
  - Engine names
  - Quantity name
  - Measured values
  - Tolerance threshold
  - Possible causes (e.g., integration method, constraint handling)

### Q. GUI & Visualization Standards

#### Q1. PyQt6 Architecture

- **Model-View Separation**: Business logic in separate modules, not in UI classes
- **Signal/Slot Hygiene**:
  - Explicit type annotations for custom signals
  - No lambda slots (use named methods for debuggability)
  - Disconnect signals in cleanup methods
- **Thread Safety**:
  - Long-running computations in `QThread` workers
  - GUI updates only from main thread via signals
  - No blocking operations in event handlers

#### Q2. 3D Visualization Requirements

- **Headless Fallback**: All 3D viewers must detect headless environments and provide:
  - Offscreen rendering (EGL/OSMesa)
  - Screenshot export
  - Graceful degradation message
- **Frame Rate**: Maintain ≥ 30 FPS for real-time visualization
- **Coordinate Frame Indicators**:
  - World frame always visible (toggleable)
  - Body frames color-coded (X=red, Y=green, Z=blue)
  - Scale adaptive to model size

#### Q3. Export & Reproducibility

- **Versioned Exports**: All exported data must include:
  - Schema version
  - Export timestamp (ISO 8601 UTC)
  - Software version (`golf-modeling-suite==X.Y.Z`)
  - Engine name and version
- **Analysis Bundles** (L2 requirement):
  - Single archive (.zip or .tar.gz) containing:
    - Model files (URDF, meshes)
    - Input data (C3D, initial conditions)
    - Simulation parameters (timestep, integrator, tolerances)
    - Output data (states, forces, diagnostics)
    - Metadata (JSON manifest)

### R. Documentation & Knowledge Management

#### R1. Docstring Standards

- **All Public APIs**: NumPy-style docstrings with:
  - One-line summary
  - Extended description (if non-trivial)
  - Args (with types and units where applicable)
  - Returns (with type and shape for arrays)
  - Raises (for expected exceptions)
  - Examples (for complex functions)
- **Physical Units**: Always document units in docstrings:
  ```python
  def compute_torque(force: float, lever_arm: float) -> float:
      """Compute torque from force and lever arm.
      
      Args:
          force: Applied force [N]
          lever_arm: Perpendicular distance [m]
      
      Returns:
          Torque [N·m]
      """
  ```

#### R2. Adversarial Review Cycle

- **Quarterly Assessments**: Run standardized audit prompts (A, B, C) from `docs/assessments/`
- **Prompt A**: Python architecture and software patterns
- **Prompt B**: Scientific rigor and numerical correctness
- **Prompt C**: Physics engine integration and cross-validation
- **Results Storage**: `docs/assessments/Assessment_{A,B,C}_Results.md`
- **Action Items**: All "CRITICAL" findings must be addressed within 2 weeks

#### R3. Changelog & Migration Guides

- **Breaking Changes**: Require migration guide in `docs/development/`
- **Deprecation Policy**: 2-release warning period before removal
- **Version Semantics**: Follow SemVer 2.0.0
  - MAJOR: Breaking API changes
  - MINOR: New features, backward-compatible
  - PATCH: Bug fixes, no API changes

### S. OpenPose Motion Matching Requirements (Ultimate Goal)

These standards apply specifically to the forward dynamics motion matching workflow:

#### S1. Marker-to-Model Registration Pipeline

- **Input**: C3D marker trajectories (≥ 60 Hz recommended)
- **Output**: Joint angle trajectories (q(t)) + residuals
- **IK Solver Requirements**:
  - Constraint-consistent (respect closed loops)
  - Regularization for redundant DOFs (damped least squares, λ = 0.01)
  - Per-frame residual reporting (RMS marker error)
  - Outlier detection (residual > 3σ flagged)
- **Parameter Estimation**:
  - Segment lengths from marker geometry
  - Mass/inertia from anthropometric tables (with uncertainty bounds)
  - Sensitivity analysis (∂q/∂p for key parameters p)

#### S2. Trajectory Optimization Standards

- **Objective Function**:
  - Primary: Minimize marker residuals (weighted least squares)
  - Secondary: Minimize control effort (∫ τ² dt)
  - Tertiary: Smoothness penalty (∫ q̈² dt)
- **Constraints**:
  - Dynamics feasibility (M(q)q̈ + C(q,q̇) + G(q) = τ)
  - Joint limits (q_min ≤ q ≤ q_max)
  - Torque limits (|τ| ≤ τ_max, from biomechanical data)
  - Contact constraints (if ground interaction modeled)
- **Solver Requirements**:
  - Support for direct collocation or shooting methods
  - Warm-start from IK solution
  - Convergence tolerance: cost reduction < 1e-6 or max 500 iterations

#### S3. Validation Metrics

- **Kinematic Fidelity**:
  - Marker RMS error < 10 mm (excellent), < 20 mm (acceptable)
  - Joint angle correlation with IK solution: R² > 0.95
- **Dynamic Consistency**:
  - Indexed acceleration closure: |q̈_total - Σ q̈_components| < 1e-3 rad/s²
  - Energy balance: |ΔE - W_external| < 5% (for conservative phases)
- **Cross-Engine Agreement**:
  - Torque profiles: RMS difference < 10% between engines
  - Clubhead trajectory: position error < 5 mm, velocity error < 0.5 m/s

---

## Appendix: Suggested "Causality Demo" Test Case

A standard benchmark swing (or simplified analog) used to validate every engine:

- Closed‑chain two‑hand club constraint enabled
- Prescribed kinematics segment (for inverse dynamics)
- Free swing segment (for drift/counterfactual)
- Perturbation tests:
  - torque perturbations
  - parameter perturbations (mass/inertia/length)
  - constraint stiffness (if applicable)
- Required outputs:
  - ZTCF/ZVCF deltas
  - induced + indexed acceleration closure
  - ellipsoid evolution
  - cross‑engine comparison report
