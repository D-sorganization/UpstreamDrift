---
title: "Golf Modeling App — Mission & Required Features"
subtitle: "A living mission statement and acceptance checklist"
author: "Project Team"
date: "2026-01-08"
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: true
    theme: cosmo
  pdf:
    toc: true
    toc-depth: 3
    number-sections: true
execute:
  echo: true
  warning: false
  message: false
---

## Mission (Non‑Negotiable)

We are building a research‑grade platform to model the golf swing as a constrained, redundant, hybrid multibody system. This is not an animation tool, a curve‑fit engine, or a coaching dashboard. The app must enable physically faithful simulation, cross‑engine verification, and causal interpretation.

**Prime directive:** If a capability does not improve physical fidelity, interpretability, or reproducibility, it does not belong in the product.

## Core Principles

### First principles over convenience

- Equations of motion must be numerically inspectable (and ideally symbolically traceable).
- Jacobians, mass matrices, constraint forces, null spaces, and conditioning are baseline—never “advanced extras.”

### Cross‑engine consistency is a feature

We explicitly support and compare results across:

- Drake
- MuJoCo
- Pinocchio (with Crocoddyl and Pink)
- Simscape Multibody
- OpenSim‑class biomechanics features (embedded)
- MyoSuite‑style muscle/neural control experiments

Engine disagreements are diagnostics, not something to paper over.

### Closed chains are the norm

Two hands on one club is the default modeling problem. Loop constraints are first‑class and must be interrogated (Jacobian rank, constraint force magnitudes, etc.).

### Drift vs. control must be separable

We require explicit decomposition of motion and acceleration into drift (passive dynamics) and control (actuation), with counterfactual experiments (ZTCF/ZVCF) baked in.

## System Scope

### Primary workflows

1. **Build or import a model**
   - URDF authoring/generation (interactive)
   - Engine adapters (MuJoCo/Pinocchio/Drake/Simscape)
2. **Ingest experimental data**
   - C3D (markers + analog + force plates if present)
   - Model fitting / registration
3. **Simulate & optimize**
   - Forward and inverse dynamics
   - Trajectory optimization / planning
4. **Interpret**
   - Jacobians, constraints, induced + indexed acceleration
   - Force/mobility ellipsoids
   - Drift/control decomposition
   - ZTCF/ZVCF counterfactuals
5. **Validate across engines**
   - Comparable outputs, explicit tolerances, documented deviations

### Non‑goals (to stay honest)

- Consumer coaching, “swing tips,” or proprietary scoring.
- Hiding assumptions behind opaque “efficiency metrics.”
- Shipping features that cannot be validated or reproduced.

## Required Feature Set (Acceptance Checklist)

> **Rule:** Every item below must be either (a) implemented, (b) explicitly marked “not supported” with a reason, and (c) tested with an acceptance suite.

### A. Data Ingestion & Experimental Alignment

#### A1. C3D reader (mandatory)

- Read markers, analog channels, events, and metadata.
- Support multiple marker sets and partial/missing markers.
- Unit normalization + sampling‑rate handling.
- Optional force‑plate parsing where present.
- Timebase alignment and resampling utilities.

#### A2. Marker‑to‑model mapping

- Landmark mapping to model frames.
- Segment pose reconstruction (rigid body fit).
- Residuals, outlier detection, and diagnostics plots.
- Logged uncertainty / fit quality metrics.

#### A3. Model fitting & parameter identification

- Fit kinematics (DOFs) to observed trajectories.
- Parameter estimation options (segment lengths, masses/inertias).
- Report sensitivity to parameter changes.

### B. Modeling & Interoperability

#### B1. Kinematic modeling

- Trees and closed loops.
- Revolute, prismatic, and compound joints (universal/spherical via chains).
- Joint limits, damping, compliance options (where supported).

#### B2. Inertial modeling

- Segment mass properties (mass, COM, inertia tensor).
- Consistent conventions across engines.
- Visual vs. collision geometry separation.

#### B3. Interactive URDF generator (mandatory)

- GUI‑driven URDF authoring and editing.
- Parametric joint and link property editing.
- Live URDF validation (schema + physics sanity checks).
- **MuJoCo visualization embedded**:
  - Real‑time render of the generated model
  - Collision display toggles
  - Frame/axis display toggles
  - Joint limit visualization
  - Contact visualization (where possible)

#### B4. Engine adapter layer (mandatory)

- Import/export and runtime adapters for:
  - Drake
  - MuJoCo
  - Pinocchio (+ Crocoddyl + Pink)
  - Simscape Multibody
- Explicit warnings where semantics differ (no silent assumptions).

#### B5. Model Library with Human Biomechanics and Golf Equipment (mandatory)

A curated library of pre-configured URDF models for rapid prototyping and validated simulations:

**Human Biomechanical Models:**
- Integration with [human-gazebo repository](https://github.com/gbionics/human-gazebo)
- High-fidelity human models with detailed STL meshes
- License: CC-BY-SA 2.0 (properly attributed)
- Available models:
  - Human Subject with Meshes: Full body model with realistic geometry
  - Human Subject with Spinal Cord: Enhanced spinal representation
- Direct download from repository via GUI or programmatic API
- Metadata tracking (source, license, version)

**Golf Club Library:**
- Procedurally generated club URDFs with validated specifications
- Available clubs:
  - Driver (45", 10.5° loft, 310g)
  - 5-Iron (38", 28° loft, 390g)
  - 7-Iron (36.5", 34° loft, 410g)
  - 9-Iron (35", 42° loft, 430g)
  - Sand Wedge (35", 56° loft, 460g)
  - Putter (34", 3° loft, 370g)
- Realistic mass distribution:
  - Separate head, shaft, and grip components
  - Accurate center of mass and inertia tensors
  - Compliant with USGA equipment specifications
- Parametric loft angle and club geometry
- Auto-generated collision and visual geometry

**Library Management:**
- `ModelLibrary` class in `tools/urdf_generator/model_library.py`
- Directory structure: `shared/urdf/{human_models,golf_clubs}/`
- Mesh asset management: `shared/meshes/{human,golf_clubs}/`
- Versioned catalog of available models
- Download tracking and cache management

**GUI Integration:**
- "Load from Library" dialog (Ctrl+L in URDF Generator)
- Model browser with category filters (human/golf clubs)
- Model information display (specs, licensing, provenance)
- One-click download and URDF generation
- Seamless integration with existing URDF editor

**Cross-Engine Compatibility:**
- All library models must work across MuJoCo, Drake, and Pinocchio
- Validated coordinate conventions and unit consistency
- Documented engine-specific adaptations where necessary

#### B6. OpenSim-MuJoCo Conversion via MyoConverter (required for biomechanics workflows)

Integration with [MyoConverter](https://github.com/MyoHub/myoconverter) for musculoskeletal model conversion:

**Conversion Capabilities:**
- Bi-directional OpenSim (.osim) ↔ MuJoCo (.xml) conversion
- Muscle kinematics and kinetics optimization
- Automatic tendon routing and wrapping geometry translation
- Path constraint handling for moving muscle attachment points
- Hill-type muscle parameter preservation

**Validation Features:**
- Automated validation PDF report generation
- Cross-platform comparison (OpenSim vs. MuJoCo)
- Muscle force-length and force-velocity curve verification
- Joint range of motion consistency checks
- Moment arm validation at key configurations

**Integration Points:**
- `MyoConverter` class in `shared/python/myoconverter_integration.py`
- Pipeline configuration via kwargs:
  - `convert_steps`: [1, 2, 3] for full conversion
  - `muscle_list`: Specific muscles to optimize (or None for all)
  - `validation`: Enable/disable validation phase
  - `generate_pdf`: Produce validation report
  - `add_ground_geom`: Include ground geometry
- Keyframe initialization helper (models require loading keyframe 0)
- Example models catalog with URLs to validated conversions

**MyoSuite Compatibility:**
- Converted models work with MyoSuite for neural control experiments
- Muscle-driven RL policy training support
- Integration with existing MyoSuite biomechanics features (Section K)

**Installation \u0026 Documentation:**
- Installation instructions for Linux (conda), Windows/MacOS (Docker)
- Citation requirements (Wang et al. 2022, Ikkala \u0026 Hämäläinen 2022)
- Troubleshooting guide for common conversion issues
- Example conversion scripts in `examples/` directory

**Quality Requirements:**
- Converted models must pass energy conservation tests
- Muscle force contributions must sum to joint torques within tolerance
- No silent failure modes (all errors logged and reported)
- Reproducible conversions (deterministic output for same input)

### C. Kinematics, Jacobians, and Constraint Geometry

#### C1. Jacobians everywhere (mandatory, exhaustive)

Compute and expose Jacobians for all relevant bodies and task points:

- World‑frame and body‑frame geometric Jacobians (6×N).
- Linear and angular components separated.
- Key task points:
  - Clubhead, multiple points along shaft, grip
  - Left hand, right hand
  - Forearms, upper arms, torso segments
- Closed‑chain, constraint‑consistent Jacobians.

#### C2. Rank/conditioning diagnostics

- Near‑singularity detection (condition number, smallest singular value).
- Constraint Jacobian rank diagnostics.
- Null‑space basis extraction and tracking through time.

#### C3. Screw‑theoretic kinematics (required)

- Instantaneous screw axis (ISA) / twist extraction at key task points.
- Visualization of screw axis and pitch where meaningful.

### D. Dynamics Core (Forward & Inverse)

#### D1. Forward dynamics (mandatory)

- Simulate under applied torques, external wrenches, constraints, gravity.
- Deterministic integration with logged states.
- Toggle contributions:
  - Gravity only
  - Drift only (no applied torques)
  - Control only (no drift terms via counterfactual methods)
  - Constraint force influence isolated (when meaningful)

#### D2. Inverse dynamics (mandatory)

- Constraint‑consistent inverse dynamics.
- Compute:
  - Joint torques for a given motion
  - Constraint reactions (forces/torques)
- Redundant solution options:
  - Minimum‑norm torques
  - Continuity‑regularized torques
  - Null‑space objective costs

#### D3. Mass & inertia matrices (mandatory)

Expose at runtime:

- Joint‑space inertia matrix \(M(q)\)
- Bias terms (Coriolis/centrifugal + gravity effects)
- Operational‑space inertia (task‑space mass matrix) where supported
- Segment inertia tensors and transforms

### E. Forces, Torques, Wrenches, and Power

#### E1. Joint‑level forces/torques (mandatory)

For every joint and timestep, log:

- Applied torque
- Reaction torque (constraint/contacts where relevant)
- Net torque
- Joint power and cumulative work

#### E2. Segment‑level wrenches (mandatory)

- Spatial wrench on each segment.
- Contribution breakdown:
  - parent→child
  - child→parent
  - constraints/contacts
  - external loads

#### E3. Power flow & inter‑segment transfer (required)

- Power transfer between segments (not just system energy).
- Work decomposition aligned with drift/control/constraint components.

### F. Drift–Control Decomposition (Non‑Negotiable)

We require explicit decomposition of acceleration and power into:

- Drift components:
  - Coriolis/centrifugal coupling
  - gravity effects
  - passive constraint mediation
- Control components:
  - actuation (torques or muscles)
  - control‑dependent constraint interaction

Also required:

- Superposition tests and plots:
  - drift + control = full
- Clear API for “turning off” elements for analysis.

### G. Counterfactuals: ZTCF & ZVCF (Mandatory)

#### G1. ZTCF — Zero‑Torque Counterfactual

- Zero applied torques while preserving state (as defined by the experiment).
- Simulate passive evolution under drift/constraints.
- Compute delta vs. observed motion and infer torque‑attributed effects.

#### G2. ZVCF — Zero‑Velocity Counterfactual

- Zero joint velocities while preserving configuration.
- Isolate acceleration/constraint/gravity‑driven motion from momentum effects.

### H. Induced and Indexed Acceleration Analysis (Mandatory)

#### H1. Induced Acceleration Analysis (IAA)

- Decompose acceleration contributions from:
  - torques (or muscles)
  - gravity
  - Coriolis/centrifugal terms
  - constraints/contacts
- Support both torque‑driven and muscle‑driven models.

#### H2. Indexed acceleration analysis (“IAA++”)

For every timestep, produce labeled acceleration components indexed by cause:

- Applied torque components
- Constraint/loop reaction components
- Gravity components
- Coriolis/centrifugal components
- Muscle components (if present)

Must be available in:

- Joint space (\(\ddot q\))
- Segment COM acceleration
- Clubhead linear + angular acceleration

**Summation requirement:** indexed components must sum to the measured/simulated acceleration within tolerance.

### I. Mobility and Force Ellipsoids (Mandatory)

Compute and visualize for each segment/task point:

- **Mobility (velocity manipulability) ellipsoids**
  - time‑varying through swing phases
  - constraint‑aware where relevant
- **Force transmission ellipsoids**
  - mapping joint torques → task forces
  - constraint‑aware

Ellipsoids must be rendered in 3D with frame context and be exportable.

### J. OpenSim‑Class Biomechanics Features (Embedded)

> We do not merely “export to OpenSim.” We embed comparable analysis capabilities.

Required embedded biomechanics features:

- Hill‑type muscle model support (where used)
- Tendon compliance options
- Muscle routing/wrapping geometry support (baseline)
- Activation → force → joint torque mapping
- Induced acceleration compatible with muscle contributions
- Muscle contribution reports (forces, moments, power)

### K. MyoSuite‑Style Muscle + Neural Control Support

- Ability to run muscle‑driven simulations (as alternatives to torque actuation).
- Support for policy‑driven controllers (RL‑style experiments) as *validation tools*, not hype.
- Hybrid models:
  - muscles for proximal segments
  - torques for distal segments
- Comparative analysis:
  - muscle‑driven vs torque‑driven feasibility
  - energy/effort metrics with transparency

### L. Visualization & Reporting (Not Eye Candy)

Required visual layers:

- Frames, axes, coordinate systems (toggleable)
- Contacts and constraint forces (where supported)
- Jacobian null directions and singularity indicators
- Wrenches and power flow arrows
- Ellipsoids and screw axes

Required exports:

- Standard plots + CSV/NPZ style structured exports
- Engine‑agnostic “analysis bundle” exports for reproducibility

### M. Cross‑Engine Validation & Scientific Hygiene

#### M1. Feature × engine support matrix

For each feature above, we must explicitly state per engine:

- Fully supported / partially supported / unsupported
- Known limitations
- Numerical tolerance targets
- Reference tests that validate the behavior

#### M2. Acceptance test suite (mandatory)

- Deterministic seeds and fixtures.
- “Gold standard” test motions (simple pendulum, double pendulum, closed loop).
- Cross‑engine comparison tests:
  - kinematics
  - dynamics
  - Jacobians/constraints
  - counterfactual deltas
  - indexed acceleration closure

#### M3. Failure reporting is required

The system must detect and report:

- Ill conditioning / near singularities
- Constraint rank loss
- Unrealistic force magnitudes
- Energy drift or integration instability
- Inconsistent conventions across engine adapters

Silence is unacceptable; it must complain loudly and specifically.

## Definition of Done

A release is acceptable only if the platform can answer, for any swing dataset:

1. **What moved?** (kinematics)
2. **What caused it?** (indexed + induced acceleration)
3. **What could have happened instead?** (null space + counterfactuals)
4. **What was controllable?** (mobility/force ellipsoids)
5. **What assumptions mattered?** (constraints + inertias + actuation model)

If any of these cannot be answered with reproducible artifacts, the feature is incomplete.

## Project-Specific Technical Standards

This section defines **mandatory technical requirements** specific to the Golf Modeling Suite that extend the general requirements above.

### N. Code Quality & CI/CD Gates (Non-Negotiable)

All code contributions must pass these automated gates before merge:

#### N1. Formatting & Style

- **Black** (line-length=88, Python 3.11+)
  - Zero tolerance for formatting violations
  - Pre-commit hooks mandatory
- **Ruff** linting with strict rule set:
  - E/W (pycodestyle), F (pyflakes), I (isort), B (bugbear), C4 (comprehensions), UP (pyupgrade), T (print detection)
  - No `print()` statements outside designated paths (tests, scripts, tools, launchers)
  - Import order: Standard → Third-party → Local

#### N2. Type Safety

- **Mypy** strict mode for all production code
  - `disallow_untyped_defs = true`
  - `check_untyped_defs = true`
  - `warn_return_any = true`
- All public functions/methods require type hints (args + return)
- No `Any` without explicit justification comment
- No `# type: ignore` without documented reason

#### N3. Testing Requirements

- **Minimum Coverage**: 25% (Phase 1 target, increasing to 60% by Phase 3)
- **Test Categories** (via pytest markers):
  - `@pytest.mark.unit`: Fast, isolated tests
  - `@pytest.mark.integration`: Cross-component tests
  - `@pytest.mark.slow`: Long-running tests (deselected in CI)
  - `@pytest.mark.mujoco/drake/pinocchio`: Engine-specific tests
- **Deterministic Tests**: All tests must use fixed seeds for RNG
- **No External Dependencies**: Tests must not require network/filesystem access
- **Headless Compatibility**: GUI tests must run in headless environments (Xvfb)

#### N4. Security & Safety

- **No Banned Patterns**:
  - `eval()`, `exec()` (security risk)
  - Mutable default arguments (`def func(items=[])`)
  - Global variables (except constants)
  - Bare `except:` clauses
- **Dependency Scanning**: `pip-audit` must pass (no known vulnerabilities)
- **CSV Injection Prevention**: All user-provided data exported to CSV must be sanitized
- **XML Security**: Use `defusedxml` for all XML parsing

### O. Physics Engine Integration Standards

#### O1. Unified Interface Compliance

All physics engines must implement `PhysicsEngineInterface` from `shared/python/interfaces.py`:

```python
class PhysicsEngineInterface(Protocol):
    def step(self, dt: float) -> None: ...
    def reset(self) -> None: ...
    def get_state(self) -> np.ndarray: ...
    def set_state(self, state: np.ndarray) -> None: ...
    def compute_inverse_dynamics(self, qacc: np.ndarray) -> np.ndarray: ...
    # ... (full interface in shared/python/interfaces.py)
```

#### O2. State Isolation Pattern

- **Thread-Local Data**: Each physics engine instance must use private `MjData`/`MultibodyPlant` contexts
- **No Shared Mutable State**: Engines must not modify global state
- **Context Managers**: Use `with MjDataContext(model):` pattern for temporary state modifications

#### O3. Numerical Stability Requirements

- **Integration Tolerances**:
  - Position drift: < 1e-6 m per second of simulation
  - Energy conservation: < 1% drift for conservative systems
  - Constraint violation: < 1e-8 (normalized)
- **Singularity Detection**:
  - Jacobian condition number warnings at κ > 1e6
  - Automatic fallback to pseudoinverse for κ > 1e10
- **Unit Consistency**:
  - All internal computations in SI units (m, kg, s, rad)
  - Explicit conversion at I/O boundaries

### P. Data Handling & Interoperability Standards

#### P1. C3D Data Requirements

- **Mandatory Metadata**: Frame rate, marker labels, units, analog labels
- **Residual Handling**: NaN for markers with residuals > threshold (default: 10.0 mm)
- **Time Synchronization**: All data aligned to common timebase (frame 0 = t=0)
- **Export Formats**: Must support CSV, JSON (records), NPZ

#### P2. URDF Interchange Format

- **Schema Validation**: All generated URDFs must validate against URDF 1.0 schema
- **Semantic Consistency**:
  - Right-hand coordinate systems (X-forward, Y-left, Z-up for humanoid)
  - Inertia tensors in link-local frames
  - Joint axes normalized to unit vectors
- **Engine-Specific Adaptations**:
  - MuJoCo: Auto-generate `<compiler>` tags for coordinate conventions
  - Drake: Include `<drake:` extensions for contact parameters
  - Pinocchio: Ensure compatibility with `pin.buildModelFromUrdf()`

#### P3. Cross-Engine Validation Protocol

- **Reference Implementation**: Symbolic pendulum models serve as ground truth
- **Tolerance Targets** (to be documented in M1):
  - Kinematics (positions): ± 1e-6 m
  - Kinematics (velocities): ± 1e-5 m/s
  - Dynamics (accelerations): ± 1e-4 m/s²
  - Inverse dynamics (torques): ± 1e-3 N·m
  - Jacobians: ± 1e-8 (element-wise)
- **Deviation Reporting**: Any cross-engine discrepancy > tolerance must log warning with:
  - Engine names
  - Quantity name
  - Measured values
  - Tolerance threshold
  - Possible causes (e.g., integration method, constraint handling)

### Q. GUI & Visualization Standards

#### Q1. PyQt6 Architecture

- **Model-View Separation**: Business logic in separate modules, not in UI classes
- **Signal/Slot Hygiene**:
  - Explicit type annotations for custom signals
  - No lambda slots (use named methods for debuggability)
  - Disconnect signals in cleanup methods
- **Thread Safety**:
  - Long-running computations in `QThread` workers
  - GUI updates only from main thread via signals
  - No blocking operations in event handlers

#### Q2. 3D Visualization Requirements

- **Headless Fallback**: All 3D viewers must detect headless environments and provide:
  - Offscreen rendering (EGL/OSMesa)
  - Screenshot export
  - Graceful degradation message
- **Frame Rate**: Maintain ≥ 30 FPS for real-time visualization
- **Coordinate Frame Indicators**:
  - World frame always visible (toggleable)
  - Body frames color-coded (X=red, Y=green, Z=blue)
  - Scale adaptive to model size

#### Q3. Export & Reproducibility

- **Versioned Exports**: All exported data must include:
  - Schema version
  - Export timestamp (ISO 8601 UTC)
  - Software version (`golf-modeling-suite==X.Y.Z`)
  - Engine name and version
- **Analysis Bundles** (L2 requirement):
  - Single archive (.zip or .tar.gz) containing:
    - Model files (URDF, meshes)
    - Input data (C3D, initial conditions)
    - Simulation parameters (timestep, integrator, tolerances)
    - Output data (states, forces, diagnostics)
    - Metadata (JSON manifest)

### R. Documentation & Knowledge Management

#### R1. Docstring Standards

- **All Public APIs**: NumPy-style docstrings with:
  - One-line summary
  - Extended description (if non-trivial)
  - Args (with types and units where applicable)
  - Returns (with type and shape for arrays)
  - Raises (for expected exceptions)
  - Examples (for complex functions)
- **Physical Units**: Always document units in docstrings:
  ```python
  def compute_torque(force: float, lever_arm: float) -> float:
      """Compute torque from force and lever arm.
      
      Args:
          force: Applied force [N]
          lever_arm: Perpendicular distance [m]
      
      Returns:
          Torque [N·m]
      """
  ```

#### R2. Adversarial Review Cycle

- **Quarterly Assessments**: Run standardized audit prompts (A, B, C) from `docs/assessments/`
- **Prompt A**: Python architecture and software patterns
- **Prompt B**: Scientific rigor and numerical correctness
- **Prompt C**: Physics engine integration and cross-validation
- **Results Storage**: `docs/assessments/Assessment_{A,B,C}_Results.md`
- **Action Items**: All "CRITICAL" findings must be addressed within 2 weeks

#### R3. Changelog & Migration Guides

- **Breaking Changes**: Require migration guide in `docs/development/`
- **Deprecation Policy**: 2-release warning period before removal
- **Version Semantics**: Follow SemVer 2.0.0
  - MAJOR: Breaking API changes
  - MINOR: New features, backward-compatible
  - PATCH: Bug fixes, no API changes

### S. OpenPose Motion Matching Requirements (Ultimate Goal)

These standards apply specifically to the forward dynamics motion matching workflow:

#### S1. Marker-to-Model Registration Pipeline

- **Input**: C3D marker trajectories (≥ 60 Hz recommended)
- **Output**: Joint angle trajectories (q(t)) + residuals
- **IK Solver Requirements**:
  - Constraint-consistent (respect closed loops)
  - Regularization for redundant DOFs (damped least squares, λ = 0.01)
  - Per-frame residual reporting (RMS marker error)
  - Outlier detection (residual > 3σ flagged)
- **Parameter Estimation**:
  - Segment lengths from marker geometry
  - Mass/inertia from anthropometric tables (with uncertainty bounds)
  - Sensitivity analysis (∂q/∂p for key parameters p)

#### S2. Trajectory Optimization Standards

- **Objective Function**:
  - Primary: Minimize marker residuals (weighted least squares)
  - Secondary: Minimize control effort (∫ τ² dt)
  - Tertiary: Smoothness penalty (∫ q̈² dt)
- **Constraints**:
  - Dynamics feasibility (M(q)q̈ + C(q,q̇) + G(q) = τ)
  - Joint limits (q_min ≤ q ≤ q_max)
  - Torque limits (|τ| ≤ τ_max, from biomechanical data)
  - Contact constraints (if ground interaction modeled)
- **Solver Requirements**:
  - Support for direct collocation or shooting methods
  - Warm-start from IK solution
  - Convergence tolerance: cost reduction < 1e-6 or max 500 iterations

#### S3. Validation Metrics

- **Kinematic Fidelity**:
  - Marker RMS error < 10 mm (excellent), < 20 mm (acceptable)
  - Joint angle correlation with IK solution: R² > 0.95
- **Dynamic Consistency**:
  - Indexed acceleration closure: |q̈_total - Σ q̈_components| < 1e-3 rad/s²
  - Energy balance: |ΔE - W_external| < 5% (for conservative phases)
- **Cross-Engine Agreement**:
  - Torque profiles: RMS difference < 10% between engines
  - Clubhead trajectory: position error < 5 mm, velocity error < 0.5 m/s

---

### T. AI Assistant Integration & Accessibility (Non-Negotiable)

This section defines **mandatory requirements** for the AI-first transformation of the Golf Modeling Suite. The goal is to maintain scientific rigor (9.4/10 quality baseline) while democratizing access for non-expert users through AI-guided workflows.

**Prime Directive:** The AI assistant educates and guides; it never bypasses scientific validation.

#### T1. Agent-Agnostic Architecture (mandatory)

The AI integration must support multiple LLM providers without vendor lock-in:

- **Provider Support**:
  - OpenAI (GPT-4, GPT-4 Turbo)
  - Anthropic (Claude 3.x)
  - Google (Gemini)
  - Ollama (Local, FREE) — must be fully functional
  - Custom endpoints via adapter interface
- **Cost Model**:
  - Zero developer infrastructure cost
  - Users provide their own API keys
  - Fully functional without AI (graceful degradation)
- **Implementation**:
  - Agent Interface Protocol (AIP) server using JSON-RPC 2.0
  - Provider adapters translate between AIP and provider APIs
  - Capability negotiation for provider-specific features

#### T2. Workflow Engine & Guided Execution (mandatory)

Step-by-step workflows for common analyses:

- **Built-in Workflows** (minimum):
  - `first_analysis`: Complete beginner walkthrough
  - `c3d_import`: Load and validate motion capture data
  - `inverse_dynamics`: Compute joint torques
  - `cross_engine_validation`: Multi-engine comparison
  - `drift_control_decomposition`: Causal analysis
- **Workflow Features**:
  - Validation at each step with clear pass/fail feedback
  - Error recovery strategies (retry, skip, fallback, ask user)
  - Progress tracking visualization
  - Educational content interwoven with execution
- **Quality Checks**:
  - Energy conservation verification
  - Cross-engine consistency checks
  - Physical plausibility validation (torque limits, etc.)

#### T3. Educational Content System (mandatory)

Progressive disclosure with 4 expertise levels:

- **Expertise Levels**:
  - **Beginner**: No prior knowledge assumed
  - **Intermediate**: Basic physics/biomechanics understanding
  - **Advanced**: Graduate-level comprehension
  - **Expert**: Research-publication ready
- **Content Requirements**:
  - 500+ term glossary with multi-level explanations
  - Just-in-time concept explanations during workflows
  - Visual guides and diagrams for complex concepts
  - Code examples with interpretation
- **User Progression**:
  - Track user expertise level
  - Suggest topics for advancement
  - Unlock advanced features as proficiency grows

#### T4. Quality Assurance & Result Interpretation (mandatory)

Automated assessment of analysis quality:

- **Validation Checks**:
  - Energy conservation: |ΔE| < 1% for conservative phases
  - Torque plausibility: Within biomechanical limits (~500 N·m max)
  - Cross-engine agreement: Per Section P3 tolerances
  - Numerical stability: Jacobian condition number warnings
- **Result Interpretation**:
  - "Is this good?" assessment for all outputs
  - Suggested next steps based on results
  - Confidence indicators and uncertainty visualization
  - Comparison to expected ranges (where available)

#### T5. User Interface Integration (mandatory)

AI Assistant Panel in the Golf Suite Launcher:

- **Components**:
  - Conversation interface with history
  - Workflow progress tracker
  - Tool execution visualization
  - Provider configuration dialog
  - Quick action shortcuts
- **Accessibility**:
  - Beginner/Expert mode toggle
  - Keyboard navigation support
  - Clear visual hierarchy
  - Status indicators for AI connection

#### T6. Security, Privacy & Auditability (mandatory)

Strict data handling requirements:

- **API Key Security**:
  - Store in OS keyring (Windows Credential Manager / macOS Keychain / Linux Secret Service)
  - Never log API keys
  - Never transmit to developers
  - Secure deletion on removal
- **Data Privacy**:
  - Conversation history stored locally only
  - Model files never sent to AI providers (only metadata)
  - User controls all data transmission
  - Optional (user-consent) error reporting
- **Audit Trail**:
  - Log all AI tool executions
  - Reproducibility metadata for all analyses
  - Timestamp and session tracking

#### T7. Implementation Requirements (mandatory)

Technical standards for AI code:

- **Code Quality**:
  - Black/Ruff/Mypy strict compliance (same as Section N)
  - Minimum 50% test coverage for AI modules
  - No banned patterns (`eval`, mutable defaults)
  - Type hints on all public APIs
- **Architecture**:
  - Separation of UI and business logic
  - Async processing for long operations
  - Graceful timeout handling
  - Error messages with educational context
- **Dependencies**:
  - Optional AI dependencies (user installs if using AI)
  - No core functionality degradation without AI
  - Pinned versions for provider SDKs

#### T8. Success Metrics (mandatory)

Measurable outcomes for AI integration:

- **Accessibility Metrics**:
  - Time to first successful analysis: <30 minutes for beginners
  - Beginner success rate: >80% completion
  - Error recovery rate: >90% with AI guidance
  - User progression: Beginner → Intermediate in 5 sessions
- **Technical Metrics**:
  - AI response latency: <3 seconds (P95)
  - Workflow completion rate: >95%
  - Scientific validation pass rate: 100%
- **Quality Metrics**:
  - CI/CD pass rate: 100%
  - Test coverage: >50% for AI modules
  - Security vulnerabilities: 0

#### T9. Rollout Strategy (recommended)

Phased implementation approach:

- **Phase 1: Core Infrastructure (3 weeks)**:
  - AIP Server and provider adapters
  - Tool Registry and Workflow Engine
  - Basic educational content
- **Phase 2: GUI Integration (2 weeks)**:
  - AI Assistant Panel
  - Configuration dialogs
  - Workflow visualization
- **Phase 3: Content Creation (3 weeks)**:
  - Multi-level explanations
  - Glossary expansion
  - Demo workflows
- **Phase 4: Testing & Refinement (2 weeks)**:
  - User acceptance testing
  - Performance optimization
  - Security audit

#### T10. Non-Negotiable Quality Standards

These standards are absolute and cannot be waived:

1. **Scientific Integrity**: AI suggestions never bypass scientific validation
2. **Reproducibility**: All AI-assisted analyses must be reproducible
3. **Transparency**: Users always understand what the AI did
4. **Educational Accuracy**: Content is scientifically correct and citable
5. **Privacy Protection**: API keys and user data are never exposed
6. **Graceful Degradation**: System fully functional without AI features

---

## Appendix: Suggested "Causality Demo" Test Case

A standard benchmark swing (or simplified analog) used to validate every engine:

- Closed‑chain two‑hand club constraint enabled
- Prescribed kinematics segment (for inverse dynamics)
- Free swing segment (for drift/counterfactual)
- Perturbation tests:
  - torque perturbations
  - parameter perturbations (mass/inertia/length)
  - constraint stiffness (if applicable)
- Required outputs:
  - ZTCF/ZVCF deltas
  - induced + indexed acceleration closure
  - ellipsoid evolution
  - cross‑engine comparison report
