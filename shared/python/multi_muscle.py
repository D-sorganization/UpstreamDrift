"""Multi-muscle coordination and antagonist pairs.

This module models groups of muscles working together (synergists) or
against each other (antagonists) to produce joint torque.

Key concepts:
- Agonist: Muscle creating torque in the desired direction
- Antagonist: Muscle opposing the torque (provides stability/stiffness)
- Co-contraction: Simultaneous activation of both to increase joint stiffness

Reference:
- Hogan (1984), "Adaptive Control of Mechanical Impedance by Co-activation of Antagonist Muscles"
"""

from __future__ import annotations

import logging
from dataclasses import dataclass
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from shared.python.hill_muscle import HillMuscleModel

logger = logging.getLogger(__name__)


@dataclass
class MuscleAttachment:
    """Defines how a muscle attaches to a joint (moment arm)."""

    muscle_name: str
    moment_arm: float  # [m] Positive = flexion, Negative = extension
    # In reality, moment arm varies with angle r(θ). Simplified here as constant.


class MuscleGroup:
    """A group of muscles acting on a single joint."""

    def __init__(self, name: str):
        """Initialize muscle group.

        Args:
            name: Group name (e.g., "Elbow Flexors")
        """
        self.name = name
        self.muscles: dict[str, HillMuscleModel] = {}
        self.attachments: dict[str, MuscleAttachment] = {}

    def add_muscle(
        self, name: str, muscle: HillMuscleModel, moment_arm: float
    ) -> None:
        """Add a muscle to the group.

        Args:
            name: Muscle identifier
            muscle: HillMuscleModel instance
            moment_arm: Moment arm [m] (+ for flexion, - for extension)
        """
        self.muscles[name] = muscle
        self.attachments[name] = MuscleAttachment(name, moment_arm)

    def compute_net_torque(
        self,
        activations: dict[str, float],
        muscle_states: dict[str, tuple[float, float]],
    ) -> float:
        """Compute net torque generated by the group.

        Args:
            activations: Dict of {muscle_name: activation}
            muscle_states: Dict of {muscle_name: (l_CE, v_CE)}

        Returns:
            Net joint torque [N·m]
        """
        net_torque = 0.0

        for name, muscle in self.muscles.items():
            if name not in activations:
                continue

            # Get state
            l_CE, v_CE = muscle_states.get(name, (muscle.params.l_opt, 0.0))

            # Create temporary state object for force computation
            from shared.python.hill_muscle import MuscleState
            state = MuscleState(
                activation=activations[name],
                l_CE=l_CE,
                v_CE=v_CE,
                l_MT=0.0 # Not used for force computation in this simplified call
            )

            # Compute force
            force = muscle.compute_force(state)

            # Add to torque (tau = r × F)
            r = self.attachments[name].moment_arm
            torque = r * force
            net_torque += torque

        return float(net_torque)


class AntagonistPair:
    """A pair of agonist/antagonist muscle groups (e.g., Biceps/Triceps)."""

    def __init__(self, agonist: MuscleGroup, antagonist: MuscleGroup):
        """Initialize antagonist pair.

        Args:
            agonist: MuscleGroup for positive torque (Flexors)
            antagonist: MuscleGroup for negative torque (Extensors)
        """
        self.agonist = agonist
        self.antagonist = antagonist

    def compute_net_torque(
        self,
        agonist_activations: dict[str, float],
        antagonist_activations: dict[str, float],
        muscle_states: dict[str, tuple[float, float]],
    ) -> float:
        """Compute net torque from both groups.

        Args:
            agonist_activations: Activations for agonist muscles
            antagonist_activations: Activations for antagonist muscles
            muscle_states: Shared state dictionary

        Returns:
            Net torque [N·m]
        """
        tau_agonist = self.agonist.compute_net_torque(
            agonist_activations, muscle_states
        )
        tau_antagonist = self.antagonist.compute_net_torque(
            antagonist_activations, muscle_states
        )

        # Antagonist moment arms are typically negative, so torque adds up correctly
        # if defined that way. Here we assume compute_net_torque handles signs via moment arms.

        return tau_agonist + tau_antagonist


def create_elbow_muscle_system() -> AntagonistPair:
    """Factory function to create a simplified elbow muscle system.

    Returns:
        AntagonistPair with Biceps (flexor) and Triceps (extensor)
    """
    from shared.python.hill_muscle import HillMuscleModel, MuscleParameters

    # Flexors (Biceps)
    flexors = MuscleGroup("Elbow Flexors")
    biceps_params = MuscleParameters(F_max=1000.0, l_opt=0.15, l_slack=0.20)
    flexors.add_muscle("biceps", HillMuscleModel(biceps_params), moment_arm=0.04)

    # Brachialis (synergist)
    brachialis_params = MuscleParameters(F_max=800.0, l_opt=0.12, l_slack=0.10)
    flexors.add_muscle("brachialis", HillMuscleModel(brachialis_params), moment_arm=0.03)

    # Extensors (Triceps)
    extensors = MuscleGroup("Elbow Extensors")
    triceps_params = MuscleParameters(F_max=1200.0, l_opt=0.18, l_slack=0.22)
    extensors.add_muscle("triceps", HillMuscleModel(triceps_params), moment_arm=-0.035)

    return AntagonistPair(flexors, extensors)


# Example usage
if __name__ == "__main__":
    elbow = create_elbow_muscle_system()

    # Test co-contraction
    flexor_act = {"biceps": 0.5, "brachialis": 0.5}
    extensor_act = {"triceps": 0.2}

    # Assume isometric state at optimal lengths
    states = {
        "biceps": (0.15, 0.0),
        "brachialis": (0.12, 0.0),
        "triceps": (0.18, 0.0)
    }

    tau_net = elbow.compute_net_torque(flexor_act, extensor_act, states)

    # Estimate stiffness (simplified: stiffness proportional to force)
    # K ≈ sum(F_i / l_opt_i * r_i^2)

    # Just printing results
    print("=" * 60)  # noqa: T201
    print("Multi-Muscle Coordination Test")  # noqa: T201
    print("=" * 60)  # noqa: T201
    print("\\nTest: Elbow flexion with antagonist co-contraction")  # noqa: T201
    print(f"\\nFlexor activations: {flexor_act}")  # noqa: T201
    print(f"Extensor activations: {extensor_act}")  # noqa: T201

    print(f"\\nNet elbow torque: {tau_net:.2f} N·m")  # noqa: T201
    print("  (Positive = flexion)")  # noqa: T201

    # Simple stiffness proxy
    K = (1000 * 0.5 + 800 * 0.5 + 1200 * 0.2) * 0.04  # Rough scaling
    print(f"\\nEstimated joint stiffness: {K:.1f} N·m/rad")  # noqa: T201
    print("  (Higher co-contraction → higher stiffness)")  # noqa: T201

    print("\\n" + "=" * 60)  # noqa: T201
    print("✓ Multi-muscle test complete")  # noqa: T201
    print("=" * 60)  # noqa: T201
