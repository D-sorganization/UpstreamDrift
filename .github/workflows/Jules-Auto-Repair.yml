name: Jules Auto-Repair (Worker)
on:
  workflow_call:
    inputs:
      run_id:
        required: true
        type: string
      branch:
        required: false
        type: string
        default: ""

jobs:
  fix:
    if: false  # DISABLED TO PREVENT PR EXPLOSION - Re-enable after fixing cleanup logic
    runs-on: ubuntu-latest
    # Prevent multiple repairs on same branch simultaneously
    concurrency:
      group: auto-repair-${{ inputs.branch || github.event.workflow_run.head_branch }}
      cancel-in-progress: false
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: "20" }
      - run: npm install -g @google/jules

      - name: Verify Branch
        id: verify
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TARGET_RUN_ID: ${{ inputs.run_id }}
        run: |
          # Get the branch name from the run ID
          BRANCH=$(gh run view $TARGET_RUN_ID --json headBranch --jq '.headBranch')

          echo "Target branch: $BRANCH"

          # 1. PROTECTED BRANCH GUARD
          # We cannot auto-repair 'main' or 'master' directly as they are likely protected.
          if [[ "$BRANCH" == "main" || "$BRANCH" == "master" ]]; then
            echo "Cannot auto-repair protected branch '$BRANCH'. Exiting."
            exit 0
          fi

          # 2. EXISTENCE CHECK
          # Check if remote branch still exists (it might have been deleted)
          if ! git ls-remote --exit-code --heads origin "$BRANCH"; then
            echo "Branch $BRANCH no longer exists. Exiting."
            exit 0
          fi

          echo "branch=$BRANCH" >> $GITHUB_OUTPUT

      - name: Fetch Logs & Fix
        if: steps.verify.outputs.branch != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
          TARGET_RUN_ID: ${{ inputs.run_id }}
        run: |
          BRANCH="${{ steps.verify.outputs.branch }}"
          if [ -z "$JULES_API_KEY" ]; then
            echo "::warning::JULES_API_KEY not configured. Skipping Jules auto-repair."
            exit 0
          fi

          gh run view $TARGET_RUN_ID --log-failed > logs.txt
          LOG_CONTENT=$(cat logs.txt)

          # REST API Implementation (Migration from CLI)
          REPO="${{ github.repository }}"
          API_BASE="https://jules.googleapis.com/v1alpha"
          
          echo "Looking up repository source..."
          SOURCES=$(curl -sf -H "X-Goog-Api-Key: $JULES_API_KEY" "$API_BASE/sources" || echo '{"sources":[]}')
          
          OWNER=$(echo "$REPO" | cut -d'/' -f1)
          REPO_NAME=$(echo "$REPO" | cut -d'/' -f2)
          
          SOURCE_ID=$(echo "$SOURCES" | jq -r ".sources[] | select(.githubRepo.owner == \"$OWNER\" and .githubRepo.repo == \"$REPO_NAME\") | .name" | head -1)
          
          if [ -z "$SOURCE_ID" ] || [ "$SOURCE_ID" = "null" ]; then
            echo "::warning::Repository $REPO not found in Jules sources."
            exit 0
          fi
          
          echo "Found source: $SOURCE_ID"

          # Create session prompt
          # We use jq to safely escape the log content for JSON
          REQUEST_JSON=$(jq -n \
            --arg source "$SOURCE_ID" \
            --arg branch "$BRANCH" \
            --arg logs "$LOG_CONTENT" \
            '{
              prompt: ("You are the AUTO REPAIR agent. A CI workflow failed on branch " + $branch + ". Here are the logs:\n\n" + $logs + "\n\nAnalyze the errors and FIX the code."),
              sourceContext: {
                source: $source,
                githubRepoContext: {
                  startingBranch: $branch
                }
              },
              automationMode: "AUTO_CREATE_PR"
            }')
          
          echo "Creating Jules session..."
          
          HTTP_CODE=$(curl -s -o /tmp/session_response.json -w "%{http_code}" -X POST \
            -H "X-Goog-Api-Key: $JULES_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$REQUEST_JSON" \
            "$API_BASE/sessions")
          
          SESSION_RESPONSE=$(cat /tmp/session_response.json)
          echo "HTTP Status: $HTTP_CODE"
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::Jules API returned HTTP $HTTP_CODE"
            echo "Response: $SESSION_RESPONSE"
            exit 1
          fi
          
          SESSION_ID=$(echo "$SESSION_RESPONSE" | jq -r '.name')
          echo "Created session: $SESSION_ID"

