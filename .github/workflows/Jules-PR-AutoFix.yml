name: Jules PR AutoFix (Direct Push with CI Verification)

# This workflow pushes fixes DIRECTLY to PR branches (like Cursor bugbot)
# and ITERATES until CI passes or max attempts reached.
#
# Key features:
# 1. Iterates up to 5 times until CI passes (with safeguards)
# 2. Waits for CI to complete and checks results
# 3. Applies comprehensive fixes: ruff, black, import sorting, autoflake
# 4. Mypy autofix agent: intelligent type error resolution (real fixes + targeted suppressions)
# 5. Verification gate - only marks success when CI passes
# 6. Safeguards: job timeout, iteration caps, max-files-per-commit limits

on:
  workflow_run:
    workflows: ["CI Standard"]
    types: [completed]
  workflow_dispatch:
    inputs:
      branch:
        description: "Branch to fix (leave empty for auto-detect)"
        required: false
        type: string
      dry_run:
        description: "Dry run - show changes without committing"
        required: false
        default: false
        type: boolean
      max_iterations:
        description: "Maximum fix iterations (1-5)"
        required: false
        default: "5"
        type: string

permissions:
  contents: write
  pull-requests: write
  actions: read
  checks: read

# Prevent concurrent fixes on the same branch
concurrency:
  group: pr-autofix-${{ github.event.workflow_run.head_branch || github.event.inputs.branch || github.ref }}
  cancel-in-progress: false

env:
  # Maximum fix attempts per window (reduced from 10 for cost control)
  MAX_FIX_ATTEMPTS: 5
  FIX_WINDOW_HOURS: 4
  # Time to wait for CI to complete (in seconds) - 10 min max
  CI_WAIT_TIMEOUT: 600
  CI_POLL_INTERVAL: 30

jobs:
  iterative-fix:
    name: Fix and Verify CI (Iterative)
    runs-on: ubuntu-latest
    timeout-minutes: 30
    # Only run on failures (not success) for workflow_run events
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'failure')

    outputs:
      final_status: ${{ steps.final-status.outputs.status }}
      iterations_used: ${{ steps.final-status.outputs.iterations }}

    steps:
      - name: Get Branch Info
        id: branch
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ -n "${{ github.event.inputs.branch }}" ]; then
            BRANCH="${{ github.event.inputs.branch }}"
          else
            BRANCH="${{ github.event.workflow_run.head_branch }}"
          fi

          echo "Target branch: $BRANCH"

          # GUARD: Don't fix protected branches directly
          if [[ "$BRANCH" == "main" || "$BRANCH" == "master" ]]; then
            echo "Cannot auto-fix protected branch '$BRANCH'. Use hotfix workflow instead."
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check if this branch has an open PR
          PR_INFO=$(gh pr list --repo "${{ github.repository }}" --head "$BRANCH" --state open --json number,headRefName --jq '.[0] // empty')

          if [ -z "$PR_INFO" ]; then
            echo "No open PR found for branch '$BRANCH'. Skipping."
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          PR_NUMBER=$(echo "$PR_INFO" | jq -r '.number')
          echo "Found PR #$PR_NUMBER for branch $BRANCH"

          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "skip=false" >> $GITHUB_OUTPUT

      - name: Check Fix Attempt Limits
        id: limits
        if: steps.branch.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BRANCH: ${{ steps.branch.outputs.branch }}
        run: |
          # Count recent autofix commits on this branch to prevent loops
          HOURS_AGO=$(date -u -d "${{ env.FIX_WINDOW_HOURS }} hours ago" +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-${{ env.FIX_WINDOW_HOURS }}H +%Y-%m-%dT%H:%M:%SZ)

          # Count commits with autofix signature in the time window
          FIX_COUNT=$(gh api "repos/${{ github.repository }}/commits?sha=$BRANCH&since=$HOURS_AGO" \
            --jq '[.[] | select(.commit.message | test("\\[AutoFix\\]|Jules PR AutoFix"))] | length' 2>/dev/null || echo "0")

          echo "Found $FIX_COUNT autofix commits in last ${{ env.FIX_WINDOW_HOURS }} hours"

          MAX_ATTEMPTS="${{ github.event.inputs.max_iterations || env.MAX_FIX_ATTEMPTS }}"

          if [ "$FIX_COUNT" -ge "$MAX_ATTEMPTS" ]; then
            echo "::warning::Max fix attempts ($MAX_ATTEMPTS) reached for branch $BRANCH. Manual intervention required."
            echo "exceeded=true" >> $GITHUB_OUTPUT
          else
            REMAINING=$((MAX_ATTEMPTS - FIX_COUNT))
            echo "remaining_attempts=$REMAINING" >> $GITHUB_OUTPUT
            echo "exceeded=false" >> $GITHUB_OUTPUT
          fi

      - name: Checkout PR Branch
        if: steps.branch.outputs.skip != 'true' && steps.limits.outputs.exceeded != 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.branch.outputs.branch }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Python
        if: steps.branch.outputs.skip != 'true' && steps.limits.outputs.exceeded != 'true'
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Fix Tools
        if: steps.branch.outputs.skip != 'true' && steps.limits.outputs.exceeded != 'true'
        run: |
          # Pin versions to match CI Standard quality gate
          pip install ruff==0.14.10 black==26.1.0 mypy==1.13.0 autoflake
          # Install project deps so mypy can resolve imports
          pip install -e ".[dev]" 2>/dev/null || pip install -e . 2>/dev/null || true

      # ============================================================
      # ITERATIVE FIX LOOP - The core improvement
      # ============================================================
      - name: Iterative Fix Loop
        id: fix-loop
        if: steps.branch.outputs.skip != 'true' && steps.limits.outputs.exceeded != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BRANCH: ${{ steps.branch.outputs.branch }}
          PR_NUMBER: ${{ steps.branch.outputs.pr_number }}
          MAX_ITERATIONS: ${{ steps.limits.outputs.remaining_attempts }}
          DRY_RUN: ${{ github.event.inputs.dry_run }}
        run: |
          iteration=0
          ci_passed=false

          while [ $iteration -lt $MAX_ITERATIONS ] && [ "$ci_passed" != "true" ]; do
            iteration=$((iteration + 1))
            echo ""
            echo "=========================================="
            echo "  ITERATION $iteration of $MAX_ITERATIONS"
            echo "=========================================="

            # Track changes
            CHANGES_MADE=""
            git_status_before=$(git status --porcelain | wc -l)

            # ===== PHASE 1: Formatting & Linting (deterministic, safe) =====

            # ----- FIX 1: Ruff linting + import sorting -----
            echo ">>> Running ruff check --fix (linting + import sorting)..."
            ruff check --fix . 2>&1 || true
            if ! git diff --quiet; then
              CHANGES_MADE="$CHANGES_MADE ruff"
              git add -A
            fi

            # ----- FIX 2: Black formatting -----
            echo ">>> Running black..."
            black . 2>&1 || true
            if ! git diff --quiet; then
              CHANGES_MADE="$CHANGES_MADE black"
              git add -A
            fi

            # ----- FIX 3: Remove unused imports -----
            echo ">>> Running autoflake..."
            autoflake --in-place --remove-all-unused-imports --recursive . 2>&1 || true
            if ! git diff --quiet; then
              CHANGES_MADE="$CHANGES_MADE autoflake"
              git add -A
            fi

            # ----- FIX 4: Re-run ruff + black for consistency after autoflake -----
            echo ">>> Re-running ruff + black (post-cleanup)..."
            ruff check --fix . 2>&1 || true
            black . 2>&1 || true
            if ! git diff --quiet; then
              CHANGES_MADE="$CHANGES_MADE post-cleanup"
              git add -A
            fi

            # ===== PHASE 2: Mypy Agent (intelligent type error fixing) =====

            echo ">>> Running mypy autofix agent..."
            if [ -f "scripts/mypy_autofix_agent.py" ]; then
              python scripts/mypy_autofix_agent.py \
                --max-fixes 20 --max-files 15 --verbose \
                --config-file pyproject.toml 2>&1 || true

              if ! git diff --quiet; then
                CHANGES_MADE="$CHANGES_MADE mypy-agent"
                # Re-run ruff + black on mypy agent's changes for formatting consistency
                ruff check --fix . 2>&1 || true
                black . 2>&1 || true
                git add -A
              fi
            else
              echo "  (mypy_autofix_agent.py not found, skipping mypy fixes)"
            fi

            # Check if any changes were made this iteration
            git_status_after=$(git status --porcelain | wc -l)

            if [ "$git_status_after" -gt "$git_status_before" ] || [ -n "$(git diff --staged)" ]; then
              echo "Changes made:$CHANGES_MADE"

              if [ "$DRY_RUN" == "true" ]; then
                echo "DRY RUN - would commit these changes:"
                git diff --staged --stat
                echo "iterations_used=$iteration" >> $GITHUB_OUTPUT
                echo "status=dry_run" >> $GITHUB_OUTPUT
                exit 0
              fi

              # Commit changes
              git config user.name "github-actions[bot]"
              git config user.email "github-actions[bot]@users.noreply.github.com"

              git commit -m "[AutoFix] Iteration $iteration: Apply fixes ($CHANGES_MADE)

          Automated fixes applied directly to PR #$PR_NUMBER branch.
          Iteration: $iteration of $MAX_ITERATIONS
          Tools used:$CHANGES_MADE

          This commit was created by Jules PR AutoFix workflow.
          CI verification loop will check if more fixes are needed.

          Co-Authored-By: Jules AutoFix <jules-bot@users.noreply.github.com>"

              # Push changes
              git push origin "$BRANCH"
              echo "âœ… Pushed iteration $iteration fixes to $BRANCH"

              # Wait for CI to start
              echo ">>> Waiting for CI to start..."
              sleep 30

              # Wait for CI to complete
              echo ">>> Waiting for CI to complete (timeout: ${{ env.CI_WAIT_TIMEOUT }}s)..."
              wait_time=0
              while [ $wait_time -lt ${{ env.CI_WAIT_TIMEOUT }} ]; do
                # Get the latest check run status
                CHECK_STATUS=$(gh pr checks "$PR_NUMBER" --json name,state,conclusion \
                  --jq '.[] | select(.name == "quality-gate" or .name == "tests") | .state' 2>/dev/null | head -1)

                if [ "$CHECK_STATUS" == "COMPLETED" ]; then
                  # Check conclusion
                  CONCLUSION=$(gh pr checks "$PR_NUMBER" --json name,conclusion \
                    --jq '.[] | select(.name == "quality-gate") | .conclusion' 2>/dev/null | head -1)

                  if [ "$CONCLUSION" == "SUCCESS" ]; then
                    echo "âœ… CI PASSED after iteration $iteration!"
                    ci_passed=true
                    break 2  # Exit both loops
                  else
                    echo "âŒ CI still failing after iteration $iteration (conclusion: $CONCLUSION)"
                    break  # Exit wait loop, continue fix loop
                  fi
                fi

                sleep ${{ env.CI_POLL_INTERVAL }}
                wait_time=$((wait_time + ${{ env.CI_POLL_INTERVAL }}))
                echo "  ... waiting ($wait_time/${{ env.CI_WAIT_TIMEOUT }}s)"
              done

              if [ $wait_time -ge ${{ env.CI_WAIT_TIMEOUT }} ]; then
                echo "âš ï¸ CI wait timeout reached, continuing with next iteration"
              fi

              # Pull any changes before next iteration
              git pull origin "$BRANCH" --rebase 2>/dev/null || true

            else
              echo "No changes made in iteration $iteration"
              # If no changes and CI still failing, we can't fix automatically
              if [ $iteration -eq 1 ]; then
                echo "::warning::No automatic fixes available. Manual intervention required."
              fi
              break
            fi
          done

          echo "iterations_used=$iteration" >> $GITHUB_OUTPUT
          if [ "$ci_passed" == "true" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=partial" >> $GITHUB_OUTPUT
          fi

      - name: Add PR Comment
        if: |
          steps.branch.outputs.skip != 'true' &&
          steps.limits.outputs.exceeded != 'true' &&
          steps.fix-loop.outputs.status != '' &&
          github.event.inputs.dry_run != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ steps.branch.outputs.pr_number }}
          STATUS: ${{ steps.fix-loop.outputs.status }}
          ITERATIONS: ${{ steps.fix-loop.outputs.iterations_used }}
        run: |
          if [ "$STATUS" == "success" ]; then
            EMOJI="âœ…"
            MESSAGE="CI is now **passing** after $ITERATIONS iteration(s)!"
          else
            EMOJI="ðŸ”§"
            MESSAGE="Applied $ITERATIONS iteration(s) of fixes. CI may still need manual attention."
          fi

          gh pr comment "$PR_NUMBER" --body "## $EMOJI AutoFix Complete

          $MESSAGE

          **Iterations used:** $ITERATIONS / ${{ env.MAX_FIX_ATTEMPTS }}
          **Fix types applied:** ruff, black, autoflake, mypy-agent

          ### What was fixed:
          - Code formatting (black)
          - Linting & import sorting (ruff --fix)
          - Unused imports (autoflake)
          - Type errors (mypy autofix agent - real fixes + targeted suppressions)

          ---
          *Jules PR AutoFix with CI Verification Loop*"

      - name: Final Status
        id: final-status
        if: always()
        run: |
          echo "status=${{ steps.fix-loop.outputs.status || 'skipped' }}" >> $GITHUB_OUTPUT
          echo "iterations=${{ steps.fix-loop.outputs.iterations_used || '0' }}" >> $GITHUB_OUTPUT

      - name: Generate Summary
        if: always()
        run: |
          echo "## Jules PR AutoFix Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ steps.branch.outputs.branch || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **PR:** #${{ steps.branch.outputs.pr_number || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Skipped:** ${{ steps.branch.outputs.skip }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Limit Exceeded:** ${{ steps.limits.outputs.exceeded || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Final Status:** ${{ steps.fix-loop.outputs.status || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Iterations Used:** ${{ steps.fix-loop.outputs.iterations_used || '0' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.fix-loop.outputs.status }}" == "success" ]; then
            echo "### âœ… CI Verification: PASSED" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.fix-loop.outputs.status }}" == "partial" ]; then
            echo "### âš ï¸ CI Verification: Partial (manual review needed)" >> $GITHUB_STEP_SUMMARY
          fi
