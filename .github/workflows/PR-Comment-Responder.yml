name: PR Comment Collector

# Collects PR comments into a queue for batch processing
# Does NOT act immediately - prevents workflow cascades
# Comments are processed by Jules-Comment-Processor on a schedule

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]

permissions:
  contents: write
  pull-requests: read
  issues: read

# Prevent concurrent runs from corrupting the queue file
concurrency:
  group: pr-comment-collector-${{ github.repository }}
  cancel-in-progress: false

jobs:
  collect-comment:
    # Only run on PR comments (not issue comments)
    if: |
      (github.event_name == 'pull_request_review_comment') ||
      (github.event_name == 'issue_comment' && github.event.issue.pull_request != null)
    runs-on: ubuntu-latest

    steps:
      - name: Filter Bot Comments
        id: filter
        run: |
          ACTOR="${{ github.actor }}"

          # List of bot actors to ignore
          BOTS="copilot-pull-request-reviewer[bot] cursor[bot] dependabot[bot] github-actions[bot] renovate[bot] codecov[bot] sonarcloud[bot]"

          for bot in $BOTS; do
            if [ "$ACTOR" = "$bot" ]; then
              echo "::notice::Ignoring comment from bot: $ACTOR"
              echo "is_bot=true" >> $GITHUB_OUTPUT
              exit 0
            fi
          done

          echo "is_bot=false" >> $GITHUB_OUTPUT

      - name: Get PR State
        id: pr_state
        if: steps.filter.outputs.is_bot != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ "${{ github.event_name }}" = "pull_request_review_comment" ]; then
            PR_NUMBER="${{ github.event.pull_request.number }}"
          else
            PR_NUMBER="${{ github.event.issue.number }}"
          fi

          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT

          # Check if PR is already merged or closed
          PR_STATE=$(gh pr view "$PR_NUMBER" --repo "${{ github.repository }}" --json state --jq '.state')
          echo "pr_state=$PR_STATE" >> $GITHUB_OUTPUT

          if [ "$PR_STATE" = "MERGED" ] || [ "$PR_STATE" = "CLOSED" ]; then
            echo "::notice::PR #$PR_NUMBER is $PR_STATE, skipping comment collection"
            echo "should_skip=true" >> $GITHUB_OUTPUT
          else
            echo "should_skip=false" >> $GITHUB_OUTPUT
          fi

      - uses: actions/checkout@v4
        if: steps.filter.outputs.is_bot != 'true' && steps.pr_state.outputs.should_skip != 'true'
        with:
          fetch-depth: 1

      - name: Analyze Comment
        id: analyze
        if: steps.filter.outputs.is_bot != 'true' && steps.pr_state.outputs.should_skip != 'true'
        run: |
          # Get comment body
          if [ "${{ github.event_name }}" = "pull_request_review_comment" ]; then
            COMMENT_BODY="${{ github.event.comment.body }}"
            COMMENT_PATH="${{ github.event.comment.path }}"
            COMMENT_LINE="${{ github.event.comment.line }}"
            COMMENT_TYPE="review"
          else
            COMMENT_BODY="${{ github.event.comment.body }}"
            COMMENT_PATH=""
            COMMENT_LINE=""
            COMMENT_TYPE="pr"
          fi

          # Check if comment is actionable (contains request-like words)
          BODY_LOWER=$(echo "$COMMENT_BODY" | tr '[:upper:]' '[:lower:]')

          IS_ACTIONABLE=false
          for word in "please" "should" "could you" "can you" "fix" "change" "update" "add" "remove" "consider" "suggest" "recommend"; do
            if echo "$BODY_LOWER" | grep -q "$word"; then
              IS_ACTIONABLE=true
              break
            fi
          done

          # Also check for question marks (requests for clarification/changes)
          if echo "$COMMENT_BODY" | grep -q "?"; then
            IS_ACTIONABLE=true
          fi

          echo "is_actionable=$IS_ACTIONABLE" >> $GITHUB_OUTPUT

          if [ "$IS_ACTIONABLE" = "false" ]; then
            echo "::notice::Comment does not appear actionable, skipping"
          fi

      - name: Queue Comment for Processing
        if: |
          steps.filter.outputs.is_bot != 'true' &&
          steps.pr_state.outputs.should_skip != 'true' &&
          steps.analyze.outputs.is_actionable == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          mkdir -p .jules/pending
          QUEUE_FILE=".jules/pending/pr_comments.json"

          # Initialize queue file if it doesn't exist
          if [ ! -f "$QUEUE_FILE" ]; then
            echo '{"comments": []}' > "$QUEUE_FILE"
          fi

          # Create comment entry
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          PR_NUMBER="${{ steps.pr_state.outputs.pr_number }}"

          if [ "${{ github.event_name }}" = "pull_request_review_comment" ]; then
            COMMENT_ID="${{ github.event.comment.id }}"
            COMMENT_BODY=$(echo '${{ toJson(github.event.comment.body) }}')
            COMMENT_PATH="${{ github.event.comment.path }}"
            COMMENT_LINE="${{ github.event.comment.line }}"
            COMMENT_TYPE="review"
            COMMENT_AUTHOR="${{ github.event.comment.user.login }}"
          else
            COMMENT_ID="${{ github.event.comment.id }}"
            COMMENT_BODY=$(echo '${{ toJson(github.event.comment.body) }}')
            COMMENT_PATH=""
            COMMENT_LINE=""
            COMMENT_TYPE="pr"
            COMMENT_AUTHOR="${{ github.event.comment.user.login }}"
          fi

          # Use Python for safe JSON manipulation
          python3 << PYEOF
          import json
          import os

          queue_file = "$QUEUE_FILE"

          # Load existing queue
          try:
              with open(queue_file, 'r') as f:
                  queue = json.load(f)
          except:
              queue = {"comments": []}

          # Check for duplicate (same comment ID)
          comment_id = "$COMMENT_ID"
          existing_ids = [c.get('comment_id') for c in queue.get('comments', [])]

          if comment_id in existing_ids:
              print(f"Comment {comment_id} already in queue, skipping")
          else:
              # Add new comment
              new_comment = {
                  "comment_id": comment_id,
                  "pr_number": int("$PR_NUMBER"),
                  "type": "$COMMENT_TYPE",
                  "author": "$COMMENT_AUTHOR",
                  "body": $COMMENT_BODY,
                  "path": "$COMMENT_PATH" if "$COMMENT_PATH" else None,
                  "line": int("$COMMENT_LINE") if "$COMMENT_LINE" else None,
                  "queued_at": "$TIMESTAMP",
                  "repository": "${{ github.repository }}"
              }

              queue["comments"].append(new_comment)
              queue["last_updated"] = "$TIMESTAMP"

              with open(queue_file, 'w') as f:
                  json.dump(queue, f, indent=2)

              print(f"Queued comment {comment_id} from PR #{new_comment['pr_number']}")
              print(f"Queue now has {len(queue['comments'])} pending comments")
          PYEOF

      - name: Commit Queue Update
        if: |
          steps.filter.outputs.is_bot != 'true' &&
          steps.pr_state.outputs.should_skip != 'true' &&
          steps.analyze.outputs.is_actionable == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add .jules/pending/pr_comments.json

          if ! git diff --staged --quiet; then
            git commit -m "chore: queue PR comment for batch processing

          PR: #${{ steps.pr_state.outputs.pr_number }}
          Comment ID: ${{ github.event.comment.id }}

          This comment will be processed by Jules-Comment-Processor on the next scheduled run."

            git push
            echo "::notice::Comment queued for batch processing"
          else
            echo "No changes to commit"
          fi
