name: Jules Control Tower

on:
  push:
    branches: [main]
  pull_request:
    types: [opened, synchronize, closed]
  workflow_run:
    workflows: ["CI Standard"]
    types: [completed]
  schedule:
    # OVERNIGHT SCHEDULE - All work done before morning (midnight-6 AM PST / 8 AM-2 PM UTC)
    - cron: "0 8 * * *"   # Midnight PST - Assessment Generator
    - cron: "30 8 * * *"  # 12:30 AM PST - Code Quality Reviewer
    - cron: "0 9 * * *"   # 1 AM PST - Completist (incomplete impl)
    - cron: "30 10 * * *" # 2:30 AM PST - Sentinel (security)
    - cron: "0 11 * * *"  # 3 AM PST - Tech Custodian
    - cron: "30 11 * * *" # 3:30 AM PST - Issue Resolver (daily fix)
    - cron: "0 12 * * *"  # 4 AM PST - PR Compiler (consolidate PRs)
  workflow_dispatch:
    inputs:
      target:
        description: "Worker to dispatch (auto uses schedule routing)"
        required: false
        default: "auto"
        type: choice
        options:
          - auto
          - assessment-generator
          - code-quality-reviewer
          - completist
          - sentinel
          - tech-custodian
          - issue-resolver
          - pr-compiler

# SAFEGUARD: Maximum iterations to prevent infinite repair loops
env:
  MAX_REPAIR_ITERATIONS: 3
  MAX_ITERATIONS_WINDOW_HOURS: 1

concurrency:
  group: jules-control-tower-${{ github.repository }}
  cancel-in-progress: false

permissions:
  contents: write
  pull-requests: write
  actions: write
  issues: write
  security-events: write

jobs:
  triage:
    runs-on: ubuntu-latest
    # Removed global actor check to allow scheduled runs even if file modified by bot
    outputs:
      target: ${{ steps.decide.outputs.target }}
    steps:
      # SAFEGUARD: Check if we've exceeded max repair iterations in the time window
      - name: Check Iteration Limits
        id: check-limits
        if: github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'failure'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Checking repair iteration limits..."
          BRANCH="${{ github.event.workflow_run.head_branch }}"
          HOURS_AGO=$(date -u -d "${{ env.MAX_ITERATIONS_WINDOW_HOURS }} hours ago" +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-${{ env.MAX_ITERATIONS_WINDOW_HOURS }}H +%Y-%m-%dT%H:%M:%SZ)

          FAILURE_COUNT=$(gh run list \
            --workflow="CI Standard" \
            --branch="$BRANCH" \
            --limit=20 \
            --json conclusion,createdAt,status \
            --jq "[.[] | select(.conclusion == \"failure\" and .createdAt > \"$HOURS_AGO\")] | length" \
            2>/dev/null || echo "0")

          if [ "$FAILURE_COUNT" -ge "${{ env.MAX_REPAIR_ITERATIONS }}" ]; then
            echo "::error::Max repair iterations reached. Manual intervention required."
            echo "exceeded=true" >> $GITHUB_OUTPUT
          else
            echo "exceeded=false" >> $GITHUB_OUTPUT
          fi

      - name: Analyze Event Context
        id: decide
        if: steps.check-limits.outcome == 'skipped' || steps.check-limits.outputs.exceeded != 'true'
        uses: actions/github-script@v8
        with:
          script: |
            const event = context.eventName;
            const actor = context.actor;
            const schedule = context.payload.schedule;
            const manualTarget = context.payload.inputs?.target;
            let target = "none";

            console.log(`Event: ${event}, Actor: ${actor}, Schedule: ${schedule}`);

            // 0. MANUAL DISPATCH - Honor explicit target selection
            if (event === "workflow_dispatch" && manualTarget && manualTarget !== "auto") {
              target = manualTarget;
              console.log(`Manual dispatch: ${target}`);
            }
            // 1. CI FAILURE -> AUTO-REPAIR or HOTFIX-CREATOR
            else if (event === "workflow_run" && context.payload.workflow_run.conclusion === "failure") {
               // Allow bot to trigger repair (handled by check-limits loop protection)
               const failedBranch = context.payload.workflow_run.head_branch;
               if (failedBranch === "main" || failedBranch === "master") {
                  target = "hotfix-creator";
               } else {
                  target = "auto-repair";
               }
            }
            // 2. SCHEDULED RUNS - Route by cron pattern (deterministic) with UTC time fallback
            else if (event === "schedule" || (event === "workflow_dispatch" && (!manualTarget || manualTarget === "auto"))) {
              // Always run schedules regardless of actor
              // Primary: Match exact cron pattern for deterministic routing
              if (schedule) {
                switch (schedule) {
                  case "0 8 * * *":
                    target = "assessment-generator";
                    break;
                  case "30 8 * * *":
                    target = "code-quality-reviewer";
                    break;
                  case "0 9 * * *":
                    target = "completist";
                    break;
                  case "30 10 * * *":
                    target = "sentinel";
                    break;
                  case "0 11 * * *":
                    target = "tech-custodian";
                    break;
                  case "30 11 * * *":
                    target = "issue-resolver";
                    break;
                  case "0 12 * * *":
                    target = "pr-compiler";
                    break;
                  default:
                    target = "none";
                }
              }

              // Fallback: UTC time-based routing (for workflow_dispatch with auto or edge cases)
              if (target === "none") {
                const now = new Date();
                const hour = now.getUTCHours();
                const minute = now.getUTCMinutes();

                if (hour === 8 && minute < 30) {
                  target = "assessment-generator";
                } else if (hour === 8 && minute >= 30) {
                  target = "code-quality-reviewer";
                } else if (hour === 9 && minute < 30) {
                  target = "completist";
                } else if (hour === 10 && minute >= 30) {
                  target = "sentinel";
                } else if (hour === 11 && minute < 30) {
                  target = "tech-custodian";
                } else if (hour === 11 && minute >= 30) {
                  target = "issue-resolver";
                } else if (hour === 12) {
                  target = "pr-compiler";
                } else {
                  target = "none";
                }
              }
            }
            // 3. PUSH TO MAIN -> DOCS
            else if (event === "push" && context.ref === "refs/heads/main") {
              if (actor === 'jules-bot' || actor === 'jules-ai[bot]') {
                 console.log("Ignoring push by bot to prevent doc-scribe loops.");
                 target = "none";
              } else {
                 target = "doc-scribe";
              }
            }
            // 4. NEW PR -> TEST GENERATOR
            else if (event === "pull_request" && context.payload.action === 'opened') {
               if (actor === 'jules-bot' || actor === 'jules-ai[bot]') {
                  console.log("Ignoring PR open by bot.");
                  target = "none";
               } else {
                  target = "test-generator";
               }
            }
            // 5. PR CLOSED -> ARCHIVIST
            else if (event === "pull_request" && context.payload.action === 'closed' && context.payload.pull_request.merged) {
               target = "archivist";
            }

            console.log(`Decision: Dispatching [${target}]`);
            core.setOutput("target", target);

  # --- WORKER DISPATCH ---

  call-repair:
    needs: triage
    if: needs.triage.outputs.target == 'auto-repair'
    uses: ./.github/workflows/Jules-Auto-Repair.yml
    with:
      run_id: ${{ github.event.workflow_run.id }}
      branch: ${{ github.event.workflow_run.head_branch }}
    secrets: inherit

  call-hotfix-creator:
    needs: triage
    if: needs.triage.outputs.target == 'hotfix-creator'
    uses: ./.github/workflows/Jules-Hotfix-Creator.yml
    with:
      run_id: ${{ github.event.workflow_run.id }}
      failed_branch: ${{ github.event.workflow_run.head_branch }}
    secrets: inherit

  call-scribe:
    needs: triage
    if: needs.triage.outputs.target == 'doc-scribe'
    uses: ./.github/workflows/Jules-Documentation-Scribe.yml
    secrets: inherit

  call-tests:
    needs: triage
    if: needs.triage.outputs.target == 'test-generator'
    uses: ./.github/workflows/Jules-Test-Generator.yml
    secrets: inherit

  call-custodian:
    needs: triage
    if: needs.triage.outputs.target == 'tech-custodian'
    uses: ./.github/workflows/Jules-Tech-Custodian.yml
    secrets: inherit

  call-archivist:
    needs: triage
    if: needs.triage.outputs.target == 'archivist'
    uses: ./.github/workflows/Jules-Archivist.yml
    secrets: inherit

  call-sentinel:
    needs: triage
    if: needs.triage.outputs.target == 'sentinel'
    uses: ./.github/workflows/Jules-Sentinel.yml
    secrets: inherit

  call-code-quality-reviewer:
    needs: triage
    if: needs.triage.outputs.target == 'code-quality-reviewer'
    uses: ./.github/workflows/Jules-Code-Quality-Reviewer.yml
    secrets: inherit

  call-assessment-generator:
    needs: triage
    if: needs.triage.outputs.target == 'assessment-generator'
    uses: ./.github/workflows/Jules-Assessment-Generator.yml
    secrets: inherit

  call-issue-resolver:
    needs: triage
    if: needs.triage.outputs.target == 'issue-resolver'
    uses: ./.github/workflows/Jules-Issue-Resolver.yml
    secrets: inherit

  call-completist:
    needs: triage
    if: needs.triage.outputs.target == 'completist'
    uses: ./.github/workflows/Jules-Completist.yml
    secrets: inherit

  call-pr-compiler:
    needs: triage
    if: needs.triage.outputs.target == 'pr-compiler'
    uses: ./.github/workflows/Jules-PR-Compiler.yml
    secrets: inherit
